<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: linux | Jqlblue's Blog]]></title>
  <link href="http://jqlblue.github.io/tags/linux/atom.xml" rel="self"/>
  <link href="http://jqlblue.github.io/"/>
  <updated>2014-04-11T17:23:46+08:00</updated>
  <id>http://jqlblue.github.io/</id>
  <author>
    <name><![CDATA[jqlblue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何静态编译php]]></title>
    <link href="http://jqlblue.github.io/blog/2014/04/09/statically-compile-php/"/>
    <updated>2014-04-09T18:13:00+08:00</updated>
    <id>http://jqlblue.github.io/blog/2014/04/09/statically-compile-php</id>
    <content type="html"><![CDATA[<p>有些时候，我们写了一个php脚本，但是对方的服务器上没有php环境。</p>

<p>这时，我们可以通过静态方式编译php，并将相关扩展一起打包进php可执行文件，然后在运行脚本时指定php binary。</p>

<p>安装步骤如下：</p>

<ul>
<li><p>准备源文件
<code>
wget -c http://www.php.net/get/php-5.5.11.tar.gz/from/this/mirror
tar zxvf php-5.5.11.tar.gz
wget http://pecl.php.net/get/redis-2.2.5.tgz
tar xvf redis-2.2.5.tgz
mv redis-2.2.5 php-5.5.11/ext/redis
</code></p></li>
<li><p>重新生成configure
<code>
cd php-5.5.11
rm -f ./configure
./buildconf --force
</code></p></li>
<li><p>configure
<code>
./configure LDFLAGS=-static \
--prefix=/usr/local/php5-static \
--disable-all \
--enable-shared=no \
--enable-static=yes \
--enable-inline-optimization \
--enable-hash \
--enable-mbstring \
--with-layout=GNU \
--enable-filter \
--with-pcre-regex \
--with-zlib \
--enable-json \
--enable-ctype \
--disable-redis-session \
--enable-redis
</code></p></li>
<li><p>修改Makefile</p></li>
</ul>


<p>将
<code>
BUILD_CLI = $(LIBTOOL) --mode=link $(CC) -export-dynamic $(CFLAGS_CLEAN) $(EXTRA_CFLAGS) $(EXTRA_LDFLAGS_PROGRAM) $(LDFLAGS) $(PHP_RPATHS) $(PHP_GLOBAL_OBJS) $(PHP_BINARY_OBJS) $(PHP_CLI_OBJS) $(EXTRA_LIBS) $(ZEND_EXTRA_LIBS) -o $(SAPI_CLI_PATH)
BUILD_CGI = $(LIBTOOL) --mode=link $(CC) -export-dynamic $(CFLAGS_CLEAN) $(EXTRA_CFLAGS) $(EXTRA_LDFLAGS_PROGRAM) $(LDFLAGS) $(PHP_RPATHS) $(PHP_GLOBAL_OBJS) $(PHP_BINARY_OBJS) $(PHP_CGI_OBJS) $(EXTRA_LIBS) $(ZEND_EXTRA_LIBS) -o $(SAPI_CGI_PATH)
</code>
替换成
<code>
BUILD_CLI = $(LIBTOOL) --mode=link $(CC) $(CFLAGS_CLEAN) $(EXTRA_CFLAGS) $(EXTRA_LDFLAGS_PROGRAM) $(LDFLAGS) $(PHP_RPATHS) $(PHP_GLOBAL_OBJS) $(PHP_BINARY_OBJS) $(PHP_CLI_OBJS) $(EXTRA_LIBS) $(ZEND_EXTRA_LIBS) -all-static -o $(SAPI_CLI_PATH)
BUILD_CGI = $(LIBTOOL) --mode=link $(CC) $(CFLAGS_CLEAN) $(EXTRA_CFLAGS) $(EXTRA_LDFLAGS_PROGRAM) $(LDFLAGS) $(PHP_RPATHS) $(PHP_GLOBAL_OBJS) $(PHP_BINARY_OBJS) $(PHP_CGI_OBJS) $(EXTRA_LIBS) $(ZEND_EXTRA_LIBS) -all-static -o $(SAPI_CGI_PATH)
</code>
即：</p>

<p>在<code>BUILD_CLI</code>和<code>BUILD_CGI</code>对应的行中移除<code>-export-dynamic</code>，在<code>-o $(SAPI_CGI_PATH)</code>和<code>-o $(SAPI_CLI_PATH)</code>之前，添加<code>-all-static</code></p>

<ul>
<li><p>继续安装
<code>
make LDFLAGS=-ldl
sudo make install
</code></p></li>
<li><p>检查</p></li>
</ul>


<p>在命令行执行</p>

<pre><code>$ file /usr/local/php5-static/bin/php
/usr/local/php5-static/bin/php: ELF 64-bit LSB executable, AMD x86-64, version 1 (SYSV), for GNU/Linux 2.6.9, statically linked, for GNU/Linux 2.6.9, not stripped

$ /usr/local/php5-static/bin/php -m
[PHP Modules]
Core
ctype
date
ereg
filter
hash
json
mbstring
pcre
redis
Reflection
SPL
standard
zlib

[Zend Modules]
</code></pre>

<p>因为可执行文件中包含了调试信息，所以体积较大</p>

<pre><code>$ ll -h /usr/local/php5-static/bin/php
-rwxr-xr-x 1 root root 18M 04-09 18:11 /usr/local/php5-static/bin/php
</code></pre>

<p>可以通过<code>strip</code>命令移除调试信息</p>

<pre><code>$ sudo strip /usr/local/php5-static/bin/php
$ ll -h /usr/local/php5-static/bin/php
-rwxr-xr-x 1 root root 6.1M 04-09 18:11 /usr/local/php5-static/bin/php
</code></pre>

<p>reference：</p>

<p>[^1] <a href="http://www.php.net/manual/zh/install.pecl.static.php">http://www.php.net/manual/zh/install.pecl.static.php</a></p>

<p>[^2] <a href="http://d.hatena.ne.jp/shimooka/comment/20110216/1297827454">http://d.hatena.ne.jp/shimooka/comment/20110216/1297827454</a></p>

<p>[^3] <a href="http://www.gnu.org/software/libtool/manual/html_node/Link-mode.html">http://www.gnu.org/software/libtool/manual/html_node/Link-mode.html</a></p>

<p>[^4] <a href="http://markmail.org/message/cpoenglavs4vwv32">http://markmail.org/message/cpoenglavs4vwv32</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux文件系统如何进行文件存取]]></title>
    <link href="http://jqlblue.github.io/blog/2014/03/29/read-wirite-on-linux-file-system/"/>
    <updated>2014-03-29T13:32:00+08:00</updated>
    <id>http://jqlblue.github.io/blog/2014/03/29/read-wirite-on-linux-file-system</id>
    <content type="html"><![CDATA[<p>乍一看，这个题目好像有点小儿科。</p>

<p>写文件嘛</p>

<pre><code>echo hello &gt; /tmp/foo
</code></pre>

<p>读文件嘛</p>

<pre><code>cat /tmp/foo
</code></pre>

<p>对于普通文件的存取，的确可以使用上面的方法。但是在linux操作系统上，一
切都是文件。除了<code>普通文件</code>，还包括：<code>目录</code>，<code>符号链接</code>，<code>IPC Endpoints</code>（如pipe，unix socket）和<code>设备文件</code>(块设备，字符设备)。</p>

<p>当然，本文的重点不在于介绍相关操作技巧，而是希望可以探寻操作背后的机制。</p>

<p>我们要存取的文件，一般都是保存在普通的磁盘上，通过电磁变换来实现文件的读取和写入。所以我们先从磁盘说起。</p>

<h3>磁盘物理结构</h3>

<p><em>磁盘的机械结构如下图</em>：</p>

<p><img src="/images/os/disk-structure.png" title="&lsquo;disk strucrure" ></p>

<p>如上图，一块磁盘中有好几块<code>盘片</code>（platter），一个盘片上的盘面被划分成若干个同心圆（即<code>磁道</code>（track））。
将磁盘上<code>机械臂</code>的<code>磁头</code>径向移动到盘面的相关位置（磁道）后，通过盘片在磁头下方的高速旋转，就可以读取并写入所在<code>柱面</code>（cylinder）上的数据。</p>

<p><em>盘面的示意图如下</em>：</p>

<p><img src="/images/os/disk-structure-2.gif" title="&lsquo;disk strucrure" ></p>

<p>磁盘是个块设备，它的最小存储单位是<code>扇区</code>（sector），每个扇区存取512字节。</p>

<p>为了提升文件的读取效率，文件系统会以<code>块</code>（block）为单位进行文件读取。块是linux系统上文件存取的最小单位，一个块一般为连续的8个扇区，即4K。</p>

<p>直接对磁盘等硬件进行操作，是很困难的。不过操作系统的主要任务就是隐藏硬件，呈现良好，清晰，优雅，一致的抽象。linux文件系统对文件的处理进行了良好的抽象。</p>

<h3>VFS虚拟文件系统</h3>

<p>linux文件系统的体系结构图如下：</p>

<p><img src="/images/os/fs-structure.gif" title="&lsquo;linux file system strucrure" ></p>

<p>用户态的程序要进行文件读写时，只要通过系统调用，调用VFS提供的接口就好。</p>

<p>虽然VFS需要调用ext2，ext3，NFS等具体的文件系统实现进行磁盘上文件的操作。但是它屏蔽了下层的各种异构文件系统的特点，为上层提供了统一的接口。</p>

<p>以ext2文件系统为例，其文件系统结构图示意如下：</p>

<p><img src="/images/os/ext2-fs-structure.gif" title="&lsquo;ext2 file system strucrure" ></p>

<ul>
<li>一块硬盘会被划分成多个分区</li>
<li>每个分区挂载着相应的文件系统具体实现，如ext2</li>
<li>为了减少需要管理的block的数量，在ext2文件系统产生了块组的概念。每个块组包含多个block，并且有独立的superblock和inode。</li>
</ul>


<p><em>相关名词说明</em></p>

<p><code>Boot Sector</code></p>

<pre><code>即引导扇区。包括：本分区的操作系统类型，数据区大小，根目录区允许的最大目录项
</code></pre>

<p><code>Super Block</code></p>

<pre><code>超级块。定义了文件系统的静态结构，包括：分区中每个block的大小，分区中block group的数目，以及每个block group中有inode等。每个block group不一定都有超级块，其他block group中的超级块仅仅是block group 0中超级块的一个拷贝，以备当block group 0中的超级块损坏时可以对其进行恢复。Linux启动时，block group 0中的超级块的内容会被读入到内存中。
</code></pre>

<p><code>GDT</code></p>

<pre><code>组描述符表。记录了块位图（Block Bitmap）所在块的块号，inode位图（inode Bitmap）所在块的块号，inode表（inode Table）所在块的起始块号，本组空闲块的个数等组内信息。文件系统根据这些信息来查找数据块位图，索引结点位图，索引结点表的位置
</code></pre>

<p><code>Block Bitmap</code></p>

<pre><code>Ext2文件系统的数据块位图。其中每一位对应了一个数据块，某一位上位0时表示该位所对应的数据块空闲，反之表示该位所对应的数据块已经被分配。Data Block Bitmap占了1个块的空间，因此，一个组中的数据块的个数就已经决定了。如果每个块为b-byte，那么该Group Block就有8*b个块，可以存放（8*b）*b字节的数据
</code></pre>

<p><code>Inode Bitamp</code></p>

<pre><code>inode节点位图。其工作方式跟Block Bitmap相同，只不过代表的是Inode的使用情况，每个位代表一个inode，如果是1则表示被使用，为1表示空闲
</code></pre>

<p><code>Inode Table</code></p>

<pre><code>存储inode number对应文件的元信息，包括：文件类型，权限位，链接数（有多少文件名指向这个inode），文件数据块的位置。
</code></pre>

<p><code>Data Blocks</code></p>

<pre><code>数据块存放文件的实际内容。需要特别指出的是，在Linux下目录也是一种文件。目录中的文件及子目录都以目录项（directory entry）的形式存放在该目录的数据块中。目录项中主要记录了文件的inode号，文件名以及文件类型等内容
</code></pre>

<p>Linux开机启动时，会首先载入MBR（主引导记录），MBR会告诉电脑从该设备的某一个分区来装载boot loader（boot loader储存有操作系统的相关信息，比如操作系统名称，操作系统内核 (kernel)所在位置等），通过boot loader会加载kernel，kernel通过initrd加载硬件驱动，在主分区表中搜索活动分区，加载引导分区，挂载文件系统，进行操作系统的启动。</p>

<h3>文件查找示例</h3>

<p>以查找文件/home/alex/foobar为例进行说明。</p>

<p>假设根目录（ROOT directory），在磁盘空间上的inode number是2，其对应数据块的结构如下</p>

<pre><code>    +----+-----+-----------------------------------------+
#2  |. 2 |.. 2 | home 5 | usr 9 | tmp 11 | etc 23 | ...  |
    +----+-----+-----------------------------------------+
</code></pre>

<p>通过跟目录下home目录的名字home，可以获取其inode number是5，其对应数据块的结构如下</p>

<pre><code>    +----+-----+---------------------------------------------------+
#5  |. 5 |.. 2 | alex 31 | leslie 36 | pat 39 | abcd0001 21 | ...  |
    +----+-----+---------------------------------------------------+
</code></pre>

<p>通过home目录下alex目录的名字alex，可以获取其inode number是31，其数据块的结构如下</p>

<pre><code>    +----+-----+---------------------------------------------------+
#31 |. 31|.. 5 | foobar 12 | temp 15 | literature 7 | demo 6 | ... |
    +----+-----+---------------------------------------------------+
</code></pre>

<p>继续查看inode number是12（foobar文件）的inode所对应的数据块结构，就可以获取路径为/home/alex/foobar的文件的数据内容。</p>

<pre><code>    *-----------*
#12 | file data |
    *-----------*
</code></pre>

<p>从上面也可以看出</p>

<ul>
<li>目录也是一种文件，其中包含了该目录下子目录的名字和文件名，以及其对应的inode number。</li>
<li>文件名和inode number，是多对一的关系。多个文件名可以对应同一个inode number（硬链接）</li>
</ul>


<p>为了访问路径为/home/alex/foobar的文件的数据，需要有合适的权限在根目录的inode，home目录的inode，alex目录的inode，foobar数据文件的inode。</p>

<ul>
<li>目录的inode权限，决定了是否有权限修改，移动，删除该目录，以及目录下的文件。</li>
<li>文件的inode权限，决定了是否有权限读取或者修改该文件的内容。</li>
</ul>


<h3>文件存取流程</h3>

<p>在进行文件存取时，实际上就是解析文件路径，加载相应分区上的inode table，获取对应的inode number，对inode number对于的数据块进行存取。</p>

<p>对于访问过的文件路径，会被缓存在dentry目录项中。</p>

<p>为了提升磁盘设备的IO性能，操作系统会使用内存作为磁盘设备的cache，并使用memory map方式在访问时建立与文件系统的缓存映射。文件系统的缓存，是以Page Cache为单位，一个Page Cache包含多个Buffer Cache。</p>

<ul>
<li><p>向文件中写入数据时，数据会先缓存在Page Cache中，内存中的这部分数据被标注为Dirty Page，linux系统上的pdflush守护进程会跟进系统设置将将这部分Dirty Page刷到磁盘上，也可以通过fsync系统调用在数据写入后强制刷到磁盘上。将写入的数据刷入磁盘时，是以Buffer Cache为单位，每次回写若干个Buffer Cache。</p></li>
<li><p>读取文件内容时，系统会一次性连续读取包括所请求页面在内的多个页面（如预读页面个数为n）。如果请求的页面在page cache中命中的话，会从缓存中返回页面内容，增加读取的页面数量，异步读取2n个页面;如果请求的页面没有在page cache中命中，也会增加读取页面数量，同步读取2n个页面。</p></li>
</ul>


<p>预读机制示意图</p>

<p><img src="/images/os/fs-pre-read.gif" title="&lsquo;fs preread" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在mac系统上使用emacs24打造web开发环境]]></title>
    <link href="http://jqlblue.github.io/blog/2014/02/28/emacs24-on-mac-and-linux/"/>
    <updated>2014-02-28T14:16:00+08:00</updated>
    <id>http://jqlblue.github.io/blog/2014/02/28/emacs24-on-mac-and-linux</id>
    <content type="html"><![CDATA[<h3>安装Emacs24.3</h3>

<h5>安装Homebrew</h5>

<p><code>Homebrew</code>是mac系统上的包管理软件，是用<code>Ruby</code>语言编写的。我们可以使用它在终端安装系统没有自带的<code>Unix</code>相关工具。</p>

<p><em>安装步骤</em></p>

<pre><code>ruby -e "$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)"
cd /usr/local/Library &amp;&amp; git stash &amp;&amp; git clean -d -f
</code></pre>

<h5>通过编译源代码安装Emacs</h5>

<p>在安装<code>Homebrew</code>时，会同时安装<code>gcc</code>和<code>autoconf</code>，所以我们可以直接下载源代码进行编译安装。通过如下地址可以下载到最新的emacs安装文件。</p>

<pre><code>http://www.gnu.org/software/emacs/
</code></pre>

<p>如果没有<code>wget</code>等工具，可以通过<code>brew</code>进行安装，如：</p>

<pre><code>brew install wget
</code></pre>

<p><em>安装步骤</em></p>

<pre><code>cd /somepath/
wget http://mirror.bjtu.edu.cn/gnu/emacs/emacs-24.3.tar.gz
tar zxvf emacs-24.3.tar.gz
cd emacs-24.3
./autogen.sh
./configure --with-ns
make install
sudo ln -s /somepath/emacs-24.3/nextstep/Emacs.app /Applications/Emacs24.3.app
</code></pre>

<h5>通过Homebrew安装Emacs</h5>

<p><code>Homebrew</code>本身也是下载源代码进行编译安装，但是它可以帮我们简化这一过程。这就是技术的魅力 &mdash; make live easier。</p>

<p><em>安装步骤</em></p>

<pre><code>brew install emacs --cocoa
brew linkapps
</code></pre>

<p>顺利的话，最新版的emacs就安装在mac了。如果中途遇到问题，按照提示解决下就好。</p>

<p>有可能下载地址被墙，这时通过通过修改源代码的下载地址解决，方法如下：</p>

<pre><code>1. brew edit softname，如 brew edit emacs
2. 修改其中的url，保存退出
</code></pre>

<p>如：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="n">formula</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;class Emacs &amp;lt; Formula&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">homepage</span> <span class="s1">&#39;http://www.gnu.org/software/emacs/&#39;</span>
</span><span class='line'><span class="c1">#url &#39;http://ftpmirror.gnu.org/emacs/emacs-24.3.tar.gz&#39;</span>
</span><span class='line'><span class="n">url</span> <span class="s1">&#39;http://mirror.bjtu.edu.cn/gnu/emacs/emacs-24.3.tar.gz&#39;</span>
</span><span class='line'><span class="o">&lt;</span><span class="sr">/code&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>安装完成后可以在<code>应用程序</code>，或者<code>Launchpad</code>中启动emacs，它默认长这样：</p>

<p><img src="/images/emacs/startup.png" title="&lsquo;emacs start up" ></p>

<h3>配置Emacs</h3>

<p>由于emacs24已经自带了包管理系统。只需几个简单的步骤，即可通过<a href="https://github.com/bbatsov/prelude">Emacs Prelude</a>或者<a href="https://github.com/jqlblue/goblin-emacs">Goblin Emacs</a>体验emacs的魅力。步骤如下：</p>

<pre><code>cd /somepath/
git clone https://github.com/jqlblue/goblin-emacs
ln -s /somepath/goblin-emacs ~/.emacs.d
</code></pre>

<p>启动emacs后，会自动下载需要的扩展，完成后即可体验。</p>

<p><img src="/images/emacs/goblin-startup.png" title="&lsquo;goblin emacs start up" ></p>

<p>完成<code>jedi</code>，python自动完成的配置</p>

<pre><code>cd ~/.emacs.d/elpa/jedi*
sudo pip install -r requirements.txt
</code></pre>

<p>或者指定pypi源</p>

<pre><code>sudo pip install -i http://pypi.douban.com/simple -r requirements.txt
</code></pre>

<h3>补充说明</h3>

<ul>
<li>Goblin-emacs简介</li>
</ul>


<p>goblin-emacs在prelude的基础上，对<code>PHP</code>，<code>Python</code>等<code>mode</code>进行了增强，并尽量保持原生的快捷键。相关功能介绍：</p>

<pre><code>flymake语法检测
php-mode
php基于字典的自动完成
python基于jedi的自动完成
org-mode
doxymacs 生成文档注释
slime－mode
版本控制工具的集成
</code></pre>

<p>当使用emacs编辑<code>ruby</code>或者<code>lua</code>源码时，会自动下载并安装相关<code>mode</code>，相关映射在<code>core/goblin-packages.el</code>中进行配置。</p>

<ul>
<li>交换<code>Control</code>键和<code>Caps-Lock</code>键</li>
</ul>


<p>因为emacs上的很多快捷键默认都是以<code>Control</code>开始。操作久了小拇指会比较难受，将<code>Control</code>和<code>Caps-Lock</code>进行交换，可以解放要经常蜷缩的小拇指。
<img src="/images/emacs/swap-control-capslock.png" title="&lsquo;swap control caps-lock" ></p>

<ul>
<li>某些汉字显示为方块</li>
</ul>


<p>由于某些字体不支持斜体的中文汉字等，这是就会在emacs中出现方块。解决方法如下：</p>

<pre><code>M-x customize-face RET font-lock-comment-face
修改其中的"slant"为"normal"
</code></pre>

<p>goblin－emace通过添加了如下设置解决：</p>

<pre><code>(set-fontset-font "fontset-default"
    'gb18030 '("Microsoft YaHei" . "unicode-bmp"))
)
</code></pre>

<ul>
<li>其他技巧</li>
</ul>


<p>一些常用的技巧记录如下</p>

<pre><code>通过`C-h t`可以查看emacs自带的教程
通过M-x describe-mode可以查看当前支持的mode和相关快捷键
</code></pre>

<p>reference：</p>

<p>[^1] <a href="http://earthwithsun.com/questions/631306/emacs-24-loading-a-package-installed-via-elpa">http://earthwithsun.com/questions/631306/emacs-24-loading-a-package-installed-via-elpa</a></p>

<p>[^2] <a href="http://toumorokoshi.github.io/emacs-from-scratch-part-2-package-management.html">http://toumorokoshi.github.io/emacs-from-scratch-part-2-package-management.html</a></p>

<p>[^3] <a href="http://blog.yam.com/hn12303158/article/35207136">http://blog.yam.com/hn12303158/article/35207136</a></p>

<p>[^4] <a href="http://blog.chinaunix.net/uid-26354188-id-3195392.html">http://blog.chinaunix.net/uid-26354188-id-3195392.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在fedora上安装fcitx输入法和云拼音]]></title>
    <link href="http://jqlblue.github.io/blog/2013/10/26/fcitx-fedora/"/>
    <updated>2013-10-26T12:30:00+08:00</updated>
    <id>http://jqlblue.github.io/blog/2013/10/26/fcitx-fedora</id>
    <content type="html"><![CDATA[<p>从fedora18开始，ibus感觉渐渐不如以前好用了，尤其是在emacs下使用的时候，经过死机。restart input method是家常便饭。</p>

<p>一次发现同事的ubuntu上在使用google输入法，让我眼前一亮。但是在64位的fedora19上没有配置成功。于是尝试了下fcitx输入法，特此记录。</p>

<h3>安装步骤</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>fcitx install step </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>yum install fcitx.x86_64
</span><span class='line'>yum install fcitx-configtool.x86_64
</span><span class='line'>yum install fcitx-gtk3.x86_64
</span><span class='line'>yum install fcitx-cloudpinyin.x86_64
</span><span class='line'>yum install fcitx-table-chinese.noarch
</span><span class='line'>yum intall fcitx-qt4.x86_64
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3>配置</h3>

<p>编辑~/.bashrc，添加：</p>

<pre><code>export GTK_IM_MODULE=fcitx
export QT_IM_MODULE=fcitx
export XMODIFIERS="@im=fcitx"
</code></pre>

<p>重启系统或者logout，使之生效。</p>

<pre><code>如果将im_module设置为xim，系统重启时可能会造成应用程序卡死。
此时可以通过键盘快捷键“CTRL+ALT+F2”，切换成tty2，
通过console模式登录系统杀死fcitx进程，再切回X window，或者直接重启。
</code></pre>

<h3>相关设置</h3>

<p>如下图所示：</p>

<pre><code>1. 在“input method”Tab，可以添加或者删除输入法
2. “Global Config”Tab，主要用于设置相关快捷键
3. “Appearance”列用于设置输入法弹出框的显示界面
4. 点击“Addon”Tab，通过Cloud Pinyin可以设置云拼音。即可以将谷歌拼音，搜狗，百度，QQ输入法的内容合并进来。
   下图的设置，是当输入第二个词的时候，将云拼音的结果合并到第二个位置。
</code></pre>

<p><img src="/images/fcitx_config.png" title="&lsquo;fcitx_config images&rsquo;" >
<img src="/images/fcitx_config_cloud_pinyin.png" title="&lsquo;fcitx_config_cloud_pinyin images&rsquo;" ></p>

<p>reference：</p>

<blockquote><p><a href="https://wiki.archlinux.org/index.php/Fcitx">Fcitx</a></p></blockquote>
]]></content>
  </entry>
  
</feed>
