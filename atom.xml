<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Jqlblue's Blog]]></title>
  <link href="http://jqlblue.github.io/atom.xml" rel="self"/>
  <link href="http://jqlblue.github.io/"/>
  <updated>2014-04-20T21:14:47+08:00</updated>
  <id>http://jqlblue.github.io/</id>
  <author>
    <name><![CDATA[jqlblue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何静态编译php]]></title>
    <link href="http://jqlblue.github.io/2014/04/09/statically-compile-php/"/>
    <updated>2014-04-09T18:13:00+08:00</updated>
    <id>http://jqlblue.github.io/2014/04/09/statically-compile-php</id>
    <content type="html"><![CDATA[<p>有些时候，我们写了一个php脚本，但是对方的服务器上没有php环境。</p>

<p>这时，我们可以通过静态方式编译php，并将相关扩展一起打包进php可执行文件，然后在运行脚本时指定php binary。</p>

<!-- more -->


<p>安装步骤如下：</p>

<ul>
<li>准备源文件</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wget -c http://www.php.net/get/php-5.5.11.tar.gz/from/this/mirror
</span><span class='line'>tar zxvf php-5.5.11.tar.gz
</span><span class='line'>wget http://pecl.php.net/get/redis-2.2.5.tgz
</span><span class='line'>tar xvf redis-2.2.5.tgz
</span><span class='line'>mv redis-2.2.5 php-5.5.11/ext/redis</span></code></pre></td></tr></table></div></figure>


<ul>
<li>重新生成configure</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd php-5.5.11
</span><span class='line'>rm -f ./configure
</span><span class='line'>./buildconf --force</span></code></pre></td></tr></table></div></figure>


<ul>
<li>configure</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./configure LDFLAGS=-static \
</span><span class='line'>--prefix=/usr/local/php5-static \
</span><span class='line'>--disable-all \
</span><span class='line'>--enable-shared=no \
</span><span class='line'>--enable-static=yes \
</span><span class='line'>--enable-inline-optimization \
</span><span class='line'>--enable-hash \
</span><span class='line'>--enable-mbstring \
</span><span class='line'>--with-layout=GNU \
</span><span class='line'>--enable-filter \
</span><span class='line'>--with-pcre-regex \
</span><span class='line'>--with-zlib \
</span><span class='line'>--enable-json \
</span><span class='line'>--enable-ctype \
</span><span class='line'>--disable-redis-session \
</span><span class='line'>--enable-redis</span></code></pre></td></tr></table></div></figure>


<ul>
<li>修改Makefile</li>
</ul>


<p>将</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>BUILD_CLI = $(LIBTOOL) --mode=link $(CC) -export-dynamic $(CFLAGS_CLEAN) $(EXTRA_CFLAGS) $(EXTRA_LDFLAGS_PROGRAM) $(LDFLAGS) $(PHP_RPATHS) $(PHP_GLOBAL_OBJS) $(PHP_BINARY_OBJS) $(PHP_CLI_OBJS) $(EXTRA_LIBS) $(ZEND_EXTRA_LIBS) -o $(SAPI_CLI_PATH)
</span><span class='line'>BUILD_CGI = $(LIBTOOL) --mode=link $(CC) -export-dynamic $(CFLAGS_CLEAN) $(EXTRA_CFLAGS) $(EXTRA_LDFLAGS_PROGRAM) $(LDFLAGS) $(PHP_RPATHS) $(PHP_GLOBAL_OBJS) $(PHP_BINARY_OBJS) $(PHP_CGI_OBJS) $(EXTRA_LIBS) $(ZEND_EXTRA_LIBS) -o $(SAPI_CGI_PATH)</span></code></pre></td></tr></table></div></figure>


<p>替换成</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>BUILD_CLI = $(LIBTOOL) --mode=link $(CC) $(CFLAGS_CLEAN) $(EXTRA_CFLAGS) $(EXTRA_LDFLAGS_PROGRAM) $(LDFLAGS) $(PHP_RPATHS) $(PHP_GLOBAL_OBJS) $(PHP_BINARY_OBJS) $(PHP_CLI_OBJS) $(EXTRA_LIBS) $(ZEND_EXTRA_LIBS) -all-static -o $(SAPI_CLI_PATH)
</span><span class='line'>BUILD_CGI = $(LIBTOOL) --mode=link $(CC) $(CFLAGS_CLEAN) $(EXTRA_CFLAGS) $(EXTRA_LDFLAGS_PROGRAM) $(LDFLAGS) $(PHP_RPATHS) $(PHP_GLOBAL_OBJS) $(PHP_BINARY_OBJS) $(PHP_CGI_OBJS) $(EXTRA_LIBS) $(ZEND_EXTRA_LIBS) -all-static -o $(SAPI_CGI_PATH)</span></code></pre></td></tr></table></div></figure>


<p>即：</p>

<p>在<code>BUILD_CLI</code>和<code>BUILD_CGI</code>对应的行中移除<code>-export-dynamic</code>，在<code>-o $(SAPI_CGI_PATH)</code>和<code>-o $(SAPI_CLI_PATH)</code>之前，添加<code>-all-static</code></p>

<ul>
<li>继续安装</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>make LDFLAGS=-ldl
</span><span class='line'>sudo make install</span></code></pre></td></tr></table></div></figure>


<ul>
<li>检查</li>
</ul>


<p>在命令行执行</p>

<pre><code>$ file /usr/local/php5-static/bin/php
/usr/local/php5-static/bin/php: ELF 64-bit LSB executable, AMD x86-64, version 1 (SYSV), for GNU/Linux 2.6.9, statically linked, for GNU/Linux 2.6.9, not stripped

$ /usr/local/php5-static/bin/php -m
[PHP Modules]
Core
ctype
date
ereg
filter
hash
json
mbstring
pcre
redis
Reflection
SPL
standard
zlib

[Zend Modules]
</code></pre>

<p>因为可执行文件中包含了调试信息，所以体积较大</p>

<pre><code>$ ll -h /usr/local/php5-static/bin/php
-rwxr-xr-x 1 root root 18M 04-09 18:11 /usr/local/php5-static/bin/php
</code></pre>

<p>可以通过<code>strip</code>命令移除调试信息</p>

<pre><code>$ sudo strip /usr/local/php5-static/bin/php
$ ll -h /usr/local/php5-static/bin/php
-rwxr-xr-x 1 root root 6.1M 04-09 18:11 /usr/local/php5-static/bin/php
</code></pre>

<p>reference：</p>

<p>[^1] <a href="http://www.php.net/manual/zh/install.pecl.static.php">http://www.php.net/manual/zh/install.pecl.static.php</a></p>

<p>[^2] <a href="http://d.hatena.ne.jp/shimooka/comment/20110216/1297827454">http://d.hatena.ne.jp/shimooka/comment/20110216/1297827454</a></p>

<p>[^3] <a href="http://www.gnu.org/software/libtool/manual/html_node/Link-mode.html">http://www.gnu.org/software/libtool/manual/html_node/Link-mode.html</a></p>

<p>[^4] <a href="http://markmail.org/message/cpoenglavs4vwv32">http://markmail.org/message/cpoenglavs4vwv32</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux文件系统如何进行文件存取]]></title>
    <link href="http://jqlblue.github.io/2014/03/29/read-wirite-on-linux-file-system/"/>
    <updated>2014-03-29T13:32:00+08:00</updated>
    <id>http://jqlblue.github.io/2014/03/29/read-wirite-on-linux-file-system</id>
    <content type="html"><![CDATA[<p>乍一看，这个题目好像有点小儿科。</p>

<p>写文件嘛</p>

<pre><code>echo hello &gt; /tmp/foo
</code></pre>

<p>读文件嘛</p>

<pre><code>cat /tmp/foo
</code></pre>

<p>对于普通文件的存取，的确可以使用上面的方法。但是在linux操作系统上，一
切都是文件。除了<code>普通文件</code>，还包括：<code>目录</code>，<code>符号链接</code>，<code>IPC Endpoints</code>（如pipe，unix socket）和<code>设备文件</code>(块设备，字符设备)。</p>

<p>当然，本文的重点不在于介绍相关操作技巧，而是希望可以探寻操作背后的机制。</p>

<!-- more -->


<p>我们要存取的文件，一般都是保存在普通的磁盘上，通过电磁变换来实现文件的读取和写入。所以我们先从磁盘说起。</p>

<h3>磁盘物理结构</h3>

<p><em>磁盘的机械结构如下图</em>：</p>

<p><img src="http://jqlblue.github.io/images/os/disk-structure.png" title="'disk strucrure" ></p>

<p>如上图，一块磁盘中有好几块<code>盘片</code>（platter），一个盘片上的盘面被划分成若干个同心圆（即<code>磁道</code>（track））。
将磁盘上<code>机械臂</code>的<code>磁头</code>径向移动到盘面的相关位置（磁道）后，通过盘片在磁头下方的高速旋转，就可以读取并写入所在<code>柱面</code>（cylinder）上的数据。</p>

<p><em>盘面的示意图如下</em>：</p>

<p><img src="http://jqlblue.github.io/images/os/disk-structure-2.gif" title="'disk strucrure" ></p>

<p>磁盘是个块设备，它的最小存储单位是<code>扇区</code>（sector），每个扇区存取512字节。</p>

<p>为了提升文件的读取效率，文件系统会以<code>块</code>（block）为单位进行文件读取。块是linux系统上文件存取的最小单位，一个块一般为连续的8个扇区，即4K。</p>

<p>直接对磁盘等硬件进行操作，是很困难的。不过操作系统的主要任务就是隐藏硬件，呈现良好，清晰，优雅，一致的抽象。linux文件系统对文件的处理进行了良好的抽象。</p>

<h3>VFS虚拟文件系统</h3>

<p>linux文件系统的体系结构图如下：</p>

<p><img src="http://jqlblue.github.io/images/os/fs-structure.gif" title="'linux file system strucrure" ></p>

<p>用户态的程序要进行文件读写时，只要通过系统调用，调用VFS提供的接口就好。</p>

<p>虽然VFS需要调用ext2，ext3，NFS等具体的文件系统实现进行磁盘上文件的操作。但是它屏蔽了下层的各种异构文件系统的特点，为上层提供了统一的接口。</p>

<p>以ext2文件系统为例，其文件系统结构图示意如下：</p>

<p><img src="http://jqlblue.github.io/images/os/ext2-fs-structure.gif" title="'ext2 file system strucrure" ></p>

<ul>
<li>一块硬盘会被划分成多个分区</li>
<li>每个分区挂载着相应的文件系统具体实现，如ext2</li>
<li>为了减少需要管理的block的数量，在ext2文件系统产生了块组的概念。每个块组包含多个block，并且有独立的superblock和inode。</li>
</ul>


<p><em>相关名词说明</em></p>

<p><code>Boot Sector</code></p>

<pre><code>即引导扇区。包括：本分区的操作系统类型，数据区大小，根目录区允许的最大目录项
</code></pre>

<p><code>Super Block</code></p>

<pre><code>超级块。定义了文件系统的静态结构，包括：分区中每个block的大小，分区中block group的数目，以及每个block group中有inode等。每个block group不一定都有超级块，其他block group中的超级块仅仅是block group 0中超级块的一个拷贝，以备当block group 0中的超级块损坏时可以对其进行恢复。Linux启动时，block group 0中的超级块的内容会被读入到内存中。
</code></pre>

<p><code>GDT</code></p>

<pre><code>组描述符表。记录了块位图（Block Bitmap）所在块的块号，inode位图（inode Bitmap）所在块的块号，inode表（inode Table）所在块的起始块号，本组空闲块的个数等组内信息。文件系统根据这些信息来查找数据块位图，索引结点位图，索引结点表的位置
</code></pre>

<p><code>Block Bitmap</code></p>

<pre><code>Ext2文件系统的数据块位图。其中每一位对应了一个数据块，某一位上位0时表示该位所对应的数据块空闲，反之表示该位所对应的数据块已经被分配。Data Block Bitmap占了1个块的空间，因此，一个组中的数据块的个数就已经决定了。如果每个块为b-byte，那么该Group Block就有8*b个块，可以存放（8*b）*b字节的数据
</code></pre>

<p><code>Inode Bitamp</code></p>

<pre><code>inode节点位图。其工作方式跟Block Bitmap相同，只不过代表的是Inode的使用情况，每个位代表一个inode，如果是1则表示被使用，为1表示空闲
</code></pre>

<p><code>Inode Table</code></p>

<pre><code>存储inode number对应文件的元信息，包括：文件类型，权限位，链接数（有多少文件名指向这个inode），文件数据块的位置。
</code></pre>

<p><code>Data Blocks</code></p>

<pre><code>数据块存放文件的实际内容。需要特别指出的是，在Linux下目录也是一种文件。目录中的文件及子目录都以目录项（directory entry）的形式存放在该目录的数据块中。目录项中主要记录了文件的inode号，文件名以及文件类型等内容
</code></pre>

<p>Linux开机启动时，会首先载入MBR（主引导记录），MBR会告诉电脑从该设备的某一个分区来装载boot loader（boot loader储存有操作系统的相关信息，比如操作系统名称，操作系统内核 (kernel)所在位置等），通过boot loader会加载kernel，kernel通过initrd加载硬件驱动，在主分区表中搜索活动分区，加载引导分区，挂载文件系统，进行操作系统的启动。</p>

<h3>文件查找示例</h3>

<p>以查找文件/home/alex/foobar为例进行说明。</p>

<p>假设根目录（ROOT directory），在磁盘空间上的inode number是2，其对应数据块的结构如下</p>

<pre><code>    +----+-----+-----------------------------------------+
#2  |. 2 |.. 2 | home 5 | usr 9 | tmp 11 | etc 23 | ...  |
    +----+-----+-----------------------------------------+
</code></pre>

<p>通过跟目录下home目录的名字home，可以获取其inode number是5，其对应数据块的结构如下</p>

<pre><code>    +----+-----+---------------------------------------------------+
#5  |. 5 |.. 2 | alex 31 | leslie 36 | pat 39 | abcd0001 21 | ...  |
    +----+-----+---------------------------------------------------+
</code></pre>

<p>通过home目录下alex目录的名字alex，可以获取其inode number是31，其数据块的结构如下</p>

<pre><code>    +----+-----+---------------------------------------------------+
#31 |. 31|.. 5 | foobar 12 | temp 15 | literature 7 | demo 6 | ... |
    +----+-----+---------------------------------------------------+
</code></pre>

<p>继续查看inode number是12（foobar文件）的inode所对应的数据块结构，就可以获取路径为/home/alex/foobar的文件的数据内容。</p>

<pre><code>    *-----------*
#12 | file data |
    *-----------*
</code></pre>

<p>从上面也可以看出</p>

<ul>
<li>目录也是一种文件，其中包含了该目录下子目录的名字和文件名，以及其对应的inode number。</li>
<li>文件名和inode number，是多对一的关系。多个文件名可以对应同一个inode number（硬链接）</li>
</ul>


<p>为了访问路径为/home/alex/foobar的文件的数据，需要有合适的权限在根目录的inode，home目录的inode，alex目录的inode，foobar数据文件的inode。</p>

<ul>
<li>目录的inode权限，决定了是否有权限修改，移动，删除该目录，以及目录下的文件。</li>
<li>文件的inode权限，决定了是否有权限读取或者修改该文件的内容。</li>
</ul>


<h3>文件存取流程</h3>

<p>在进行文件存取时，实际上就是解析文件路径，加载相应分区上的inode table，获取对应的inode number，对inode number对于的数据块进行存取。</p>

<p>对于访问过的文件路径，会被缓存在dentry目录项中。</p>

<p>为了提升磁盘设备的IO性能，操作系统会使用内存作为磁盘设备的cache，并使用memory map方式在访问时建立与文件系统的缓存映射。文件系统的缓存，是以Page Cache为单位，一个Page Cache包含多个Buffer Cache。</p>

<ul>
<li><p>向文件中写入数据时，数据会先缓存在Page Cache中，内存中的这部分数据被标注为Dirty Page，linux系统上的pdflush守护进程会跟进系统设置将将这部分Dirty Page刷到磁盘上，也可以通过fsync系统调用在数据写入后强制刷到磁盘上。将写入的数据刷入磁盘时，是以Buffer Cache为单位，每次回写若干个Buffer Cache。</p></li>
<li><p>读取文件内容时，系统会一次性连续读取包括所请求页面在内的多个页面（如预读页面个数为n）。如果请求的页面在page cache中命中的话，会从缓存中返回页面内容，增加读取的页面数量，异步读取2n个页面;如果请求的页面没有在page cache中命中，也会增加读取页面数量，同步读取2n个页面。</p></li>
</ul>


<p>预读机制示意图</p>

<p><img src="http://jqlblue.github.io/images/os/fs-pre-read.gif" title="'fs preread" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在mac系统上使用emacs24打造web开发环境]]></title>
    <link href="http://jqlblue.github.io/2014/02/28/emacs24-on-mac-and-linux/"/>
    <updated>2014-02-28T14:16:00+08:00</updated>
    <id>http://jqlblue.github.io/2014/02/28/emacs24-on-mac-and-linux</id>
    <content type="html"><![CDATA[<p>Emacs 是一个强大的、可扩展的文本编辑器。不同于vim，它是一个流行的无模式文本编辑器。尤其是当emacs24内置包管理elpa后，使用通过<code>prelude</code>，<code>goblin</code>等，轻松使用emacs打造一个顺手的diy的web开发环境。</p>

<!-- more -->


<h3>安装Emacs24.3</h3>

<h5>安装Homebrew</h5>

<p><code>Homebrew</code>是mac系统上的包管理软件，是用<code>Ruby</code>语言编写的。我们可以使用它在终端安装系统没有自带的<code>Unix</code>相关工具。</p>

<p><em>安装步骤</em></p>

<pre><code>ruby -e "$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)"
cd /usr/local/Library &amp;&amp; git stash &amp;&amp; git clean -d -f
</code></pre>

<h5>通过编译源代码安装Emacs</h5>

<p>在安装<code>Homebrew</code>时，会同时安装<code>gcc</code>和<code>autoconf</code>，所以我们可以直接下载源代码进行编译安装。通过如下地址可以下载到最新的emacs安装文件。</p>

<pre><code>http://www.gnu.org/software/emacs/
</code></pre>

<p>如果没有<code>wget</code>等工具，可以通过<code>brew</code>进行安装，如：</p>

<pre><code>brew install wget
</code></pre>

<p><em>安装步骤</em></p>

<pre><code>cd /somepath/
wget http://mirror.bjtu.edu.cn/gnu/emacs/emacs-24.3.tar.gz
tar zxvf emacs-24.3.tar.gz
cd emacs-24.3
./autogen.sh
./configure --with-ns
make install
sudo ln -s /somepath/emacs-24.3/nextstep/Emacs.app /Applications/Emacs24.3.app
</code></pre>

<h5>通过Homebrew安装Emacs</h5>

<p><code>Homebrew</code>本身也是下载源代码进行编译安装，但是它可以帮我们简化这一过程。这就是技术的魅力 &mdash; make live easier。</p>

<p><em>安装步骤</em></p>

<pre><code>brew install emacs --cocoa
brew linkapps
</code></pre>

<p>顺利的话，最新版的emacs就安装在mac了。如果中途遇到问题，按照提示解决下就好。</p>

<p>有可能下载地址被墙，这时通过通过修改源代码的下载地址解决，方法如下：</p>

<pre><code>1. brew edit softname，如 brew edit emacs
2. 修改其中的url，保存退出
</code></pre>

<p>如：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;formula&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Emacs</span> <span class="o">&lt;</span> <span class="no">Formula</span>
</span><span class='line'>    <span class="n">homepage</span> <span class="s1">&#39;http://www.gnu.org/software/emacs/&#39;</span>
</span><span class='line'>    <span class="c1">#url &#39;http://ftpmirror.gnu.org/emacs/emacs-24.3.tar.gz&#39;</span>
</span><span class='line'>    <span class="n">url</span> <span class="s1">&#39;http://mirror.bjtu.edu.cn/gnu/emacs/emacs-24.3.tar.gz&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>安装完成后可以在<code>应用程序</code>，或者<code>Launchpad</code>中启动emacs，它默认长这样：</p>

<p><img src="http://jqlblue.github.io/images/emacs/startup.png" title="'emacs start up" ></p>

<h3>配置Emacs</h3>

<p>由于emacs24已经自带了包管理系统。只需几个简单的步骤，即可通过<a href="https://github.com/bbatsov/prelude">Emacs Prelude</a>或者<a href="https://github.com/jqlblue/goblin-emacs">Goblin Emacs</a>体验emacs的魅力。步骤如下：</p>

<pre><code>cd /somepath/
git clone https://github.com/jqlblue/goblin-emacs
ln -s /somepath/goblin-emacs ~/.emacs.d
</code></pre>

<p>启动emacs后，会自动下载需要的扩展，完成后即可体验。</p>

<p><img src="http://jqlblue.github.io/images/emacs/goblin-startup.png" title="'goblin emacs start up" ></p>

<p>完成<code>jedi</code>，python自动完成的配置</p>

<pre><code>cd ~/.emacs.d/elpa/jedi*
sudo pip install -r requirements.txt
</code></pre>

<p>或者指定pypi源</p>

<pre><code>sudo pip install -i http://pypi.douban.com/simple -r requirements.txt
</code></pre>

<h3>补充说明</h3>

<ul>
<li>Goblin-emacs简介</li>
</ul>


<p>goblin-emacs在prelude的基础上，对<code>PHP</code>，<code>Python</code>等<code>mode</code>进行了增强，并尽量保持原生的快捷键。相关功能介绍：</p>

<pre><code>flymake语法检测
php-mode
php基于字典的自动完成
python基于jedi的自动完成
org-mode
doxymacs 生成文档注释
slime－mode
版本控制工具的集成
</code></pre>

<p>当使用emacs编辑<code>ruby</code>或者<code>lua</code>源码时，会自动下载并安装相关<code>mode</code>，相关映射在<code>core/goblin-packages.el</code>中进行配置。</p>

<ul>
<li>交换<code>Control</code>键和<code>Caps-Lock</code>键</li>
</ul>


<p>因为emacs上的很多快捷键默认都是以<code>Control</code>开始。操作久了小拇指会比较难受，将<code>Control</code>和<code>Caps-Lock</code>进行交换，可以解放要经常蜷缩的小拇指。
<img src="http://jqlblue.github.io/images/emacs/swap-control-capslock.png" title="'swap control caps-lock" ></p>

<ul>
<li>某些汉字显示为方块</li>
</ul>


<p>由于某些字体不支持斜体的中文汉字等，这是就会在emacs中出现方块。解决方法如下：</p>

<pre><code>M-x customize-face RET font-lock-comment-face
修改其中的"slant"为"normal"
</code></pre>

<p>goblin－emace通过添加了如下设置解决：</p>

<pre><code>(set-fontset-font "fontset-default"
    'gb18030 '("Microsoft YaHei" . "unicode-bmp"))
)
</code></pre>

<ul>
<li>其他技巧</li>
</ul>


<p>一些常用的技巧记录如下</p>

<pre><code>通过`C-h t`可以查看emacs自带的教程
通过M-x describe-mode可以查看当前支持的mode和相关快捷键
</code></pre>

<p>reference：</p>

<p>[^1] <a href="http://earthwithsun.com/questions/631306/emacs-24-loading-a-package-installed-via-elpa">http://earthwithsun.com/questions/631306/emacs-24-loading-a-package-installed-via-elpa</a></p>

<p>[^2] <a href="http://toumorokoshi.github.io/emacs-from-scratch-part-2-package-management.html">http://toumorokoshi.github.io/emacs-from-scratch-part-2-package-management.html</a></p>

<p>[^3] <a href="http://blog.yam.com/hn12303158/article/35207136">http://blog.yam.com/hn12303158/article/35207136</a></p>

<p>[^4] <a href="http://blog.chinaunix.net/uid-26354188-id-3195392.html">http://blog.chinaunix.net/uid-26354188-id-3195392.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用tcpcopy导入线上流量进行功能和压力测试]]></title>
    <link href="http://jqlblue.github.io/2014/01/08/use-tcpcopy-test-online/"/>
    <updated>2014-01-08T17:29:00+08:00</updated>
    <id>http://jqlblue.github.io/2014/01/08/use-tcpcopy-test-online</id>
    <content type="html"><![CDATA[<p>假设我们要上线一个两年内不会宕机的先进架构。在上线前，免不了单元测试，功能测试，还有使用ab，webbench等等进行压力测试。</p>

<p>但这些步骤非生产环境下正式用户的行为。或许你会想到灰度上线，但毕竟可能会影响到部分用户，这怎么对得起我们两年内不宕机的承诺呢？</p>

<p>好在网易的 <a href="http://weibo.com/tcpcopy">王斌</a> 开发了<a href="https://github.com/wangbin579/tcpcopy">tcpcopy</a>， 可以导入线上流量进行功能和压力测试。</p>

<!-- more -->


<h3>tcpcopy介绍</h3>

<p><code>tcpcopy</code>是一种请求复制工具。可以将线上流量拷贝到测试机器，实时的模拟线上环境。在不影响线上用户的情况下，使用线上流量进行测试，以尽早发现bug。也可以通过放大流量，进行压力测试，评估系统承载能力。</p>

<p><code>tcpcopy</code>可以从线上服务器的<code>IP</code>层抓取在线请求的数据包，修改相关属性，利用<code>raw socket output</code>技术（<code>packet injection</code> 技术之一）将其发送给测试服务器进行测试。</p>

<p>发送到测试服务器的数据包会在<code>TCP/IP</code>协议栈被识别，其中带有<code>payload</code>（tcp data）的数据包最终进入到测试服务器的上层应用（如nginx），上层应用在处理完请求之后，将响应传递给测试服务器的<code>TCP/IP</code>协议栈。</p>

<p>在测试服务器上启用<code>ip_queue</code>模块，并使用<code>iptables</code>在<code>IP</code>层将响应结果数据包发往QUEUE（<code>ip_queue</code>）。</p>

<p>测试服务器上运行在<code>用户空间</code>的拦截程序（intercept进程），通过打开<code>netlink</code>的socket接受内核通过<code>ip_queue</code>所传递来的网络数据包（即上层应用的响应内容）进行裁定，将结果返回内核，进行出队列的操作。intercept进程默认会丢弃上层应用的响应内容，返回ip header，以释放tcp连接。</p>

<p>intercept进程也可以通过<code>-x</code>（passlist）参数，不drop指定ip lists发出请求的响应内容。默认drop是为了：</p>

<pre><code>1 减少出口带宽占用，节约成本
2 不影响客户端（线上服务）的`TCP/IP`协议栈
3 不会在互联网上产生ghost数据包
</code></pre>

<h3>tcpcopy工作流程</h3>

<p><img src="http://jqlblue.github.io/images/tcpcopy_flow.png" title="'tcpcopy flow'" >
如上图，tcpcopy拷贝一次流量访问的步骤如下：</p>

<pre><code>①　一个访问到达线上前端机；
②　socket数据包在ip层被拷贝了一份传给tcpcopy进程；
③　tcpcopy修改包的目的及源地址，发给目标测试机；
④　拷贝的包到达目标测试机；
⑤　目标测试机的nginx处理访问，并返回结果；
⑥　返回结果在ip层被截获、丢弃，由intercpet进程拷贝返回结果的ip header并返回；
⑦　ip header被发送给线上前端机的tcpcopy进程。
</code></pre>

<h3>安装和配置</h3>

<p>tcpcopy有两种工作模式：</p>

<pre><code>1 实时拷贝数据包
2 通过使用tcpdump等抓包生成的文件进行离线（offline）请求重放
</code></pre>

<p>如果采用实时拷贝线上流程进行导入的方式，需要分别在线上服务器和测试服务器安装<code>tcpcopy</code>，对于离线模式，只需要在测试服务器上安装<code>tcpcopy</code>，编译时指定 <code>--enable-offline</code>。</p>

<h5>安装步骤如下：</h5>

<pre><code>wget https://github.com/wangbin579/tcpcopy/archive/0.9.0.tar.gz -O tcpcopy-0.9.0.tar.gz --no-check-certificate
tar zxvf tcpcopy-0.9.0.tar.gz
cd tcpcopy-0.9.0
./autogen.sh
./configure --prefix=/usr/local/tcpcopy
make
sudo make install
</code></pre>

<h5>目标测试机配置</h5>

<p>线上服务器拷贝的数据包发送至测试服务器进行处理之后，测试服务器需要通过<code>iptables</code>将响应结果发送至QUEUE（<code>ip_queue</code>），这样测试服务器上运行的<code>intercept</code>拦截进程才能通过打开的<code>netlink</code>socket获取传递过来的数据包并进行裁定。所以测试服务器上需要开启<code>iptables</code>防火墙，并启用内核模块<code>ip_queue</code></p>

<pre><code>modprobe ip_queue
/etc/init.d/iptables start
</code></pre>

<p>因为线上服务器需要和目标测试服务器通信，传递请求数据包和控制信息（封装的ip packet header），所以需要在测试服务器上添加相关<code>iptables</code>防火墙规则。编辑<code>/etc/sysconfig/iptables</code>，添加：</p>

<pre><code>-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT
-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 36524 -j ACCEPT
</code></pre>

<p>然后重启<code>iptables</code></p>

<pre><code>/etc/init.d/iptables restart
</code></pre>

<p>接着执行：</p>

<pre><code>iptables -I OUTPUT -p tcp --sport 80 -j QUEUE
</code></pre>

<p>将响应结果发送至QUEUE（<code>ip_queue</code>），从而实现运行在用户态的进程对相关数据包进行裁定。</p>

<h3>相关使用</h3>

<p>本文以线上和测试机的web服务都使用80端口，传递控制信息使用默认的36524端口为例。如果使用别的端口，记得修改相关<code>iptables</code>防火墙规则。</p>

<h5>离线 offline</h5>

<p>1） 在线上服务器抓包</p>

<pre><code>tcpdump -i eth0 tcp and port 80 -s 0 -w online.pcap
</code></pre>

<p>2） 将抓包生成的文件拷贝到测试服务器</p>

<p>3） 在测试服务器上进行执行如下命令进行重放</p>

<pre><code>cd /usr/local/tcpcopy/bin
sudo ./intercept
sudo ./tcpcopy -i /path/online.pcap -x 80-10.16.12.11:80

tcpcopy -i &lt;抓包文件地址&gt; -x &lt;port&gt;-&lt;本地ip&gt;:&lt;port&gt;
</code></pre>

<h5>在线实时复制 online</h5>

<p>1） 在测试服务器上启动<code>intercept</code>拦截进程</p>

<pre><code>cd /usr/local/tcpcopy/bin
sudo ./intercept
</code></pre>

<p>2） 在线上服务器复制流量到测试服务器</p>

<pre><code>cd /usr/local/tcpcopy/bin
sudo ./tcpcopy -x 80-10.16.12.11:80 -c 10.16.12.12

tcpcopy -x 服务器应用端口号-测试服务器ip地址:测试服务器应用端口 -c 本地服务器ip
</code></pre>

<p>reference：</p>

<p>[^1] <a href="https://github.com/wangbin579/tcpcopy">https://github.com/wangbin579/tcpcopy</a></p>

<p>[^2] <a href="http://www.searchtb.com/2012/05/using-tcpcopy-to-simulate-traffic.html">http://www.searchtb.com/2012/05/using-tcpcopy-to-simulate-traffic.html</a></p>

<p>[^3] <a href="http://hi.baidu.com/yacker/item/e6bd5b287fe5a3f150fd8731">http://hi.baidu.com/yacker/item/e6bd5b287fe5a3f150fd8731</a></p>

<p>[^4] <a href="http://blog.yam.com/hn12303158/article/35207136">http://blog.yam.com/hn12303158/article/35207136</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在生产环境部署sentry进行错误收集和提醒]]></title>
    <link href="http://jqlblue.github.io/2013/12/18/deploy-sentry-in-product/"/>
    <updated>2013-12-18T11:10:00+08:00</updated>
    <id>http://jqlblue.github.io/2013/12/18/deploy-sentry-in-product</id>
    <content type="html"><![CDATA[<p>Sentry正如其名，是一个实时的日志聚合平台，可以通过捕获程序事件（<code>Error</code>，<code>Exception</code>），或者主动上报的方式将错误信息等进行收集汇总和提醒，以帮助我们及时发现项目中的问题。</p>

<!-- more -->


<p>Sentry Server端是使用python语言开发的，目前有如下平台的客户端sdk：</p>

<p><code>Python</code>，<code>PHP</code>，<code>Ruby</code>，<code>Javascript</code>，<code>Java</code>，<code>Nodejs</code>，<code>IOS</code></p>

<p>项目地址：<a href="https://github.com/getsentry/sentry">https://github.com/getsentry/sentry</a></p>

<p>本文以收集<code>PHP</code>错误为例。</p>

<h3>安装步骤</h3>

<p>Sentry的文档清晰且完善，包括<code>安装</code>，<code>配置</code>，<code>调优</code>以及<code>客户端调用</code>，正式使用之前，建议看看，以加深理解。地址：<a href="http://sentry.readthedocs.org/en/latest/">http://sentry.readthedocs.org/en/latest/</a></p>

<h4>python环境安装</h4>

<p>Sentry需要python2.5以上，本文以<code>python2.7.3</code>为例，使用<code>virtualenv</code>进行环境隔离，使用<code>pip</code>安装需要的包</p>

<figure class='code'><figcaption><span>python2.7.3-install.sh </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">cd</span> ~
</span><span class='line'>yum install -y bzip2-devel.x86_64
</span><span class='line'>yum install -y sqlite-devel.x86_64
</span><span class='line'>yum install -y readline-devel.x86_64
</span><span class='line'>wget http://www.python.org/ftp/python/2.7.3/Python-2.7.3.tar.bz2
</span><span class='line'>tar jxvf Python-2.7.3.tar.bz2
</span><span class='line'><span class="nb">cd </span>Python-2.7.3
</span><span class='line'>./configure --prefix<span class="o">=</span>/usr/local/python2.7.3
</span><span class='line'>make
</span><span class='line'>sudo make install
</span><span class='line'>
</span><span class='line'>wget https://pypi.python.org/packages/source/d/distribute/distribute-0.6.49.tar.gz --no-check-certificate
</span><span class='line'>tar zxvf distribute-0.6.49.tar.gz
</span><span class='line'><span class="nb">cd </span>distribute-0.6.49
</span><span class='line'>sudo /usr/local/python2.7.3/bin/python setup.py install
</span><span class='line'>sudo /usr/local/python2.7.3/bin/easy_install virtualenv
</span><span class='line'>sudo /usr/local/python2.7.3/bin/easy_install -i http://e.pypi.python.org/simple virtualenvwrapper
</span></code></pre></td></tr></table></div></figure>


<p>至此，就完成了python2.7.3和pip，以及virtualenv的安装，使用如下命令进行测试</p>

<pre><code>/usr/local/python2.7.3/bin/python
</code></pre>

<h4>安装Sentry server</h4>

<p>初始化安装目录</p>

<pre><code>mkdir -p /data/server/python-envs
</code></pre>

<p>添加相关环境变量</p>

<pre><code>vim ~/.bashrc
</code></pre>

<p>添加：</p>

<pre><code>export WORKON_HOME=/data/server/python-envs
export VIRTUALENVWRAPPER_PYTHON=/usr/local/python2.7.3/bin/python
export VIRTUALENVWRAPPER_VIRTUALENV=/usr/local/python2.7.3/bin/virtualenv
source /usr/local/python2.7.3/bin/virtualenvwrapper.sh
</code></pre>

<p>使环境变量生效</p>

<pre><code>source ~/.bashrc
</code></pre>

<p>安装Sentry server</p>

<pre><code>mkvirtualenv sentry
pip install sentry
pip install sentry[mysql]
pip install sentry[mysql] --upgrade
</code></pre>

<p>修改<code>~/.bashrc</code>，添加如下代码，以便登录后自动切换到相关python环境</p>

<pre><code>source /data/server/python-envs/sentry/bin/activate
</code></pre>

<h3>快速配置</h3>

<p>或许你还没有做好决定，只是想尽快体验下Sentry，在完成上面的安装之后，通过下面三个步骤即可满足你的愿望：</p>

<p>1 初始化配置</p>

<pre><code>sentry init ~/sentry.conf.py
</code></pre>

<p>2 修改配置</p>

<p>修改初始配置中的如下两项就行</p>

<p><code>SENTRY_WEB_HOST</code>，<code>SENTRY_URL_PREFIX</code>，如：</p>

<pre><code>SENTRY_URL_PREFIX = 'http://10.16.15.1:9000'
SENTRY_WEB_HOST = '10.16.15.1'
</code></pre>

<p>3 创建超级管理员帐号，启动server</p>

<pre><code>sentry --config=~/sentry.conf.py upgrade
sentry --config=~/sentry.conf.py createsuperuser
sentry --config=~/sentry.conf.py start
</code></pre>

<p>然后就可以通过url <a href="http://server_host:port">http://server_host:port</a> ，使用创建的帐号登录系统后台，进行项目，帐号等管理，和已收集日志的查看等等</p>

<h3>配置在生产环境中使用</h3>

<h4>Sentry server</h4>

<p><em>我们在生产环境下的使用状况：</em></p>

<ul>
<li><p>使用<code>mysql</code>作为后端数据存储</p></li>
<li><p>使用<code>celery</code>任务队列（<code>broker</code>使用<code>redis</code>），处理数据入库，发送邮件提醒等工作</p></li>
<li><p>同时，使用<code>redis</code>作为<code>Update Buffers</code>，用于将频繁出现的相同事件合并，这在高并发时会相当有用</p></li>
<li><p>使用<code>memcache</code>作为前端<code>Cache</code>，管理后台通过轮询的访问获取是否有新的事件提醒，使用<code>memcache</code>，可以减轻直接查询数据库的压力</p></li>
<li><p>使用<code>Udp</code>协议发送并接收相关事件</p></li>
<li><p>使用<code>Nginx</code>反向代理前端http请求，并使用<code>HttpLimitReqModule</code>限制请求的发送速率</p></li>
<li><p>使用<code>supervisor</code>管理<code>celery</code>和<code>sentry</code>server</p></li>
</ul>


<p><em>相关安装步骤：</em></p>

<pre><code>pip install redis hiredis nydus
pip install redis hiredis nydus --upgrade
pip install python-memcached
pip install gevent
pip install eventlet
pip install supervisor
</code></pre>

<p><em>初始化配置</em></p>

<pre><code>mkdir -p /data/server/sentry/etc
sentry init /data/server/sentry/etc/sentry.conf.py
</code></pre>

<p><em>创建超级管理员帐号</em></p>

<pre><code>sentry --config=/data/server/sentry/etc/sentry.conf.py upgrade
sentry --config=/data/server/sentry/etc/sentry.conf.py createsuperuser
</code></pre>

<p><em>初始化supervisor配置</em></p>

<pre><code>echo_supervisord_conf &gt; /data/server/sentry/etc/supervisord.conf
</code></pre>

<p><em>配置Sentry</em></p>

<p>示例配置请参见 <a href="https://gist.github.com/jqlblue/8018185">https://gist.github.com/jqlblue/8018185</a></p>

<p>修改<code>/data/server/sentry/etc/supervisord.conf</code>，添加：</p>

<pre><code>[program:web]
command=/data/server/python-envs/sentry/bin/sentry --config=/data/server/sentry/etc/sentry.conf.py start
process_name=%(program_name)s_%(process_num)02d
numprocs=3
numprocs_start=0
startsecs=5
startretries=3
stopsignal=QUIT
stopwaitsecs=10
stopasgroup=true
killasgroup=true
environment=SENTRY_CONF="/data/server/sentry/etc/sentry.conf.py"
directory=/data/server/python-envs/sentry/

[program:sentry_udp]
command=/data/server/python-envs/sentry/bin/sentry --config=/data/server/sentry/etc/sentry.conf.py start udp
process_name=sentry_udp_server
numprocs=1
numprocs_start=0
startsecs=5
startretries=3
stopsignal=QUIT
stopwaitsecs=10
stopasgroup=true
killasgroup=true
environment=SENTRY_CONF="/data/server/sentry/etc/sentry.conf.py"
directory=/data/server/python-envs/sentry/

[program:celeryd]
command=/data/server/python-envs/sentry/bin/sentry celery worker -c 6 -P processes -l WARNING -n worker-%(process_num)02d.worker
process_name=%(program_name)s_%(process_num)02d
numprocs=1
numprocs_start=0
startsecs=1
startretries=3
stopsignal=TERM
stopwaitsecs=10
stopasgroup=false
killasgroup=true
environment=SENTRY_CONF="/data/server/sentry/etc/sentry.conf.py"
directory=/data/server/python-envs/sentry/
</code></pre>

<p><em>管理Sentry server</em></p>

<ul>
<li>启动superviord</li>
</ul>


<p>执行如下命令，同时，<code>celery</code>，<code>sentry web</code>，<code>sentry udp server</code>也将随之启动</p>

<pre><code>supervisord -c /data/server/sentry/etc/supervisord.conf
</code></pre>

<ul>
<li>停止sentry相关server</li>
</ul>


<p>执行如下命令</p>

<pre><code>supervisorctl -c /data/server/sentry/etc/supervisord.conf stop all
</code></pre>

<ul>
<li>停止superviord</li>
</ul>


<p>执行如下命令，同时，已启动的<code>centry</code>相关server也将停止</p>

<pre><code>supervisorctl -c /data/server/sentry/etc/supervisord.conf stop all
</code></pre>

<p><code>supervisor</code>更多使用方法请参见 <a href="http://supervisord.org/">http://supervisord.org/</a></p>

<p><code>nginx</code>配置请参见 <a href="https://gist.github.com/jqlblue/8019629">https://gist.github.com/jqlblue/8019629</a></p>

<h4>Sentry client</h4>

<p>可以通过在程序中<code>registerExceptionHandler</code>和<code>registerErrorHandler</code>将相关信息即时发送至server端。</p>

<p>相关sdk项目地址 <a href="https://github.com/getsentry/raven-php">https://github.com/getsentry/raven-php</a></p>

<p>实例化<code>Raven_Client</code>时使用的<code>DSN</code>中的<code>public:secret</code>可以在使用管理员登录后台后，在<code>项目</code>&ndash;<code>设置</code>下面查看到。示例地址：<a href="http://sentry_host/team_name/project_name/docs/php/">http://sentry_host/team_name/project_name/docs/php/</a></p>

<p>我们采用通过增量读取php error log，使用crontab将错误信息上报。</p>

<p>基于sentry php sdk修改之后的代码地址：<a href="https://gist.github.com/jqlblue/8019312">https://gist.github.com/jqlblue/8019312</a></p>

<p>安装依赖</p>

<pre><code>yum install -y logcheck.noarch
</code></pre>

<p><code>logcheck</code>中的<code>logtail2</code>用于增量读取日志，<code>flock</code>用于防止定时任务堆积。</p>

<blockquote><p>另外，需要安装php的sockets扩展</p></blockquote>

<p>添加定时任务</p>

<pre><code>* * * * * /usr/bin/flock -xn /tmp/sentry_client.lock /opt/php-5.5.4/bin/php /path/client.php --project=project_name 2&gt;&amp;1 &gt; /dev/null
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初探android应用性能分析]]></title>
    <link href="http://jqlblue.github.io/2013/11/22/android-app-profile-tools/"/>
    <updated>2013-11-22T18:03:00+08:00</updated>
    <id>http://jqlblue.github.io/2013/11/22/android-app-profile-tools</id>
    <content type="html"><![CDATA[<p>如果一个android应用打开时比较慢，或者使用起来比较卡。这个可能是客户端代码有待优化，也可能是服务端性能比较挫。对一个客户端开发者而言，在客户端代码中增加相关debug日志，即可比较准确地定位问题。但这活要落到一个服务端开发人员手里，要怎么办？</p>

<p>本文将在没有apk源码的情况下，以服务端开发人员的视角进行客户端app性能的分析。</p>

<!-- more -->


<p>在分析之前，我们先补充点android基础知识。</p>

<h3>android基础知识</h3>

<p>我们所说的android应用，一般都是通过将一个以apk结尾的文件安装在手机等移动设备上才能运行起来的。所以我们先从apk说起。</p>

<h5>什么是apk</h5>

<p>我们先从网上下载一个apk</p>

<pre><code>$ wget http://shouji.360tpcdn.com/131106/0124832c4cf8c35a762cfece3bac52b1/com.sina.weibo_650.apk
</code></pre>

<p>然后查看这个文件的类型</p>

<pre><code>$ file com.sina.weibo_650.apk
com.sina.weibo_650.apk: Zip archive data, at least v2.0 to extract
</code></pre>

<p>会发现<code>com.sina.weibo_650.apk</code>是一个zip压缩文件。解压缩后的文件，主要包括<em>一些资源文件</em>，<em>一些配置文件</em>，<em>一些类库</em>，还有<em>一个class.dex</em>。目录结构如下</p>

<pre><code>AndroidManifest.xml
assets
classes.dex
lib
META-INF
org
res
resources.arsc
</code></pre>

<p>粗略一看，发现 <code>class.dex</code> 这个文件有5.9M，这应该就是主角。继续执行如下命令</p>

<pre><code>$ file classes.dex
classes.dex: Dalvik dex file version 035
</code></pre>

<p>因为没有开发过android应用，不明白用java开发的app和这个Dalvik dex file之间有什么关系？所以我们先跳出apk的视角。</p>

<h5>android平台架构</h5>

<p><img src="http://jqlblue.github.io/images/mobile/android_architecture.png" title="'android architecture images'" ></p>

<p>如上图，android基于linux操作系统，使用linux内核与设备的硬件进行交互。在内核之上，又抽象出了一层，包括Dalvik虚拟机等。</p>

<p>因为<code>dex</code>是<code>Dalvik VM</code> Executes的全称，即android <code>Dalvik</code>虚拟机执行程序。</p>

<p>那一个apk的生产和执行过程将是：
<code>*.java -&gt; *.class -&gt; classes.dex（classes.dex将由Dalvik VM转换成机器码，由linux内核交给cpu去执行）</code></p>

<p>这样的话，在linux系统上使用profile软件的经验，也将派上用场。</p>

<p>android相关基础知识先介绍到此，感兴趣的请进一步查阅本文后面的参看资料。</p>

<h3>android应用性能分析</h3>

<h5>apk启动速度</h5>

<p>在分析之前，我们先看看android程序的执行流程
<img src="http://jqlblue.github.io/images/mobile/android_application_execute_flow.png" title="'android application execute flow images'" ></p>

<p>如上图，只要获取到启动ActivityManager所需要的时间，即是apk的启动时间。</p>

<pre><code>adb logcat | grep ActivityManager
</code></pre>

<p>其中&#8221;Displayed&#8221;对应的时间，即是launch Activity对应的时间，也就是apk启动时间，也可以使用如下命令：</p>

<pre><code>adb logcat -c &amp;&amp; adb logcat -s ActivityManager | grep  "Displayed"
</code></pre>

<ul>
<li>要使用 <code>adb</code>，需要先用usb线连接电脑和手机，并在手机的<code>设置</code>&ndash;><code>开发者选项</code>中开启<code>USB调试</code></li>
<li><code>adb</code>这个工具，可以通过在android sdk的platform-tools目录中找到。后面介绍的<code>systrace</code>也在这个目录。</li>
</ul>


<h5>页面渲染性能</h5>

<p>android应用中的页面，是由android系统一帧，一帧地绘制的，其中每一帧的处理如下图：
<img src="http://jqlblue.github.io/images/mobile/android_view_execute_flow.png" title="'android view execute flow images'" ></p>

<p>即：
<code>计算视图大小（measure） -&gt; 安置视图的位置（layout） -&gt; 绘制（draw）视图</code></p>

<p>通过收集每帧的处理时间，即可以了解页面的渲染性能。</p>

<blockquote><p>当fps（每秒处理帧数，页面刷新率）为60时，页面的渲染看起来会比较平滑，这就需要每帧的处理时间不能大于16ms（1000/60）</p></blockquote>

<p>要检测一个应用在渲染页面时的每帧处理时间，通过如下命令，即可获得每帧的处理时间</p>

<pre><code>adb shell dumpsys gfxinfo com.sina.weibo
</code></pre>

<p>在输出日志的<code>Profile</code>数据段，包含了三列<code>Draw</code>，<code>Process</code>，<code>Execute</code>分别对应的处理时间，单位是ms。这三列的总和，就是渲染每帧时的处理时间。如</p>

<pre><code>Draw    Process Execute
0.95    0.93    0.72
0.84    1.16    0.56
0.83    0.89    0.69
1.32    2.15    1.14
1.29    1.37    1.01
</code></pre>

<blockquote><p>在进行分析之前，需要在<code>设置</code>&ndash;><code>开发者选项</code>中点击<code>GPU呈现模式分析</code>，选择<code>在adb shell dumpsys gfxinfo中</code>。</p></blockquote>

<p>收集步骤：</p>

<pre><code>1.重新启动app
2.在界面完全加载完之后，在界面上慢慢上下滑动几个像素
3.在终端执行adb shell dumpsys gfxinfo com.sina.weibo
</code></pre>

<p>这时将在终端输出页面渲染时的最后128帧中每帧所花费的时间，将相关数据贴到excel表格中，点击其中的<code>insert</code>&ndash;><code>chart</code>，即可生成相关图表
<img src="http://jqlblue.github.io/images/mobile/frame_render_time.png" title="'frame render time images'" ></p>

<blockquote><p>其中<code>com.sina.weibo</code>就是app的包名</p></blockquote>

<p>获取包名的方法:</p>

<pre><code>adb shell pm list packages
</code></pre>

<h5>使用systrace进一步分析</h5>

<p>通过收集该apk的启动速度和每帧的渲染时间，并与竟品进行对比发现。该app启动时间的确比较慢，也偶尔有丢帧的现象发生。如何近一步分析呢？这时就需要<code>systrace</code>了。</p>

<p>示例使用方法如下：</p>

<pre><code>cd android-sdk-linux/platform-tools/systrace
python systrace.py --app=com.qihoo.appstore gfx view
</code></pre>

<p>上面这条命令将会在<code>android-sdk-linux/platform-tools/systrace</code>目录下生成<code>trace.html</code>。其中收集了包名为<code>com.qihoo.appstore</code>的应用在android系统上针对<code>gfx</code>和<code>view</code> category的执行数据。</p>

<p><code>trace.html</code>在浏览器中打开如下图：
<img src="http://jqlblue.github.io/images/mobile/android_systrace_output.png" title="'android systrace output images'" ></p>

<p>可以使用如下方法，对<code>trace.html</code>进行进一步分析：
* 通过鼠标点击左侧的<code>+</code>，<code>-</code>可以展开或者收缩相关显示数据
* 通过键盘上的<code>a</code>，<code>d</code>可以使显示的内容沿着顶部的时间轴向左或者向右移动
* 通过键盘上的<code>w</code>，<code>s</code>可以对显示的内容进行放大或者缩小
* 使用鼠标点击内容页面的某一个块，在下方会显示详情
* 使用鼠标选择一块内容页面，在下方会显示汇总信息</p>

<p>将光标定位到最后一行，使用<code>w</code>进行放大，使用<code>d</code>向左移动到2260ms左右，如下图：
<img src="http://jqlblue.github.io/images/mobile/android_systrace_output_zoom.png" title="'android systrace output detail images'" ></p>

<p>发现对于那些<code>performTraversals</code>处理超过16ms的帧，其中<code>eglSwapBuffers</code>处理的时间都比较长，这应该就是问题所在。</p>

<p>使用usb线连接上手机，在命令行下运行：</p>

<pre><code>python systrace.py -h
</code></pre>

<p>可以查看相关使用方法。</p>

<blockquote><p>systrace是在在android4.1上新增的工具，在4.1,4.2和4.3上使用的方法不同</p></blockquote>

<p>reference：</p>

<p>[^1] <a href="http://www.curious-creature.org/docs/android-performance-case-study-1.html">http://www.curious-creature.org/docs/android-performance-case-study-1.html</a></p>

<p>[^2] <a href="http://www.curious-creature.org/docs/android-performance-case-study-1.html">http://www.curious-creature.org/docs/android-performance-case-study-1.html</a></p>

<p>[^3] <a href="http://www.vogella.com/articles/AndroidTools/article.html">http://www.vogella.com/articles/AndroidTools/article.html</a></p>

<p>[^4] <a href="http://blog.csdn.net/aaa2832/article/details/7849400">http://blog.csdn.net/aaa2832/article/details/7849400</a></p>

<p>[^5] <a href="http://www.cnblogs.com/taobox/articles/3405931.html">http://www.cnblogs.com/taobox/articles/3405931.html</a></p>

<p>[^6] <a href="http://bigflake.com/systrace/">http://bigflake.com/systrace/</a></p>

<p>[^7] <a href="http://developer.android.com/tools/debugging/systrace.html">http://developer.android.com/tools/debugging/systrace.html</a></p>

<p>[^8] <a href="http://kitoslab-eng.blogspot.com/2013/01/aprof-android-profiler-profiling-tool.html">http://kitoslab-eng.blogspot.com/2013/01/aprof-android-profiler-profiling-tool.html</a></p>

<p>[^9] <a href="http://udinic.wordpress.com/tag/rendering/">http://udinic.wordpress.com/tag/rendering/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在php5.5中使用pdo和mysql_escape_string的一个坑]]></title>
    <link href="http://jqlblue.github.io/2013/11/16/pdo-mysql-escape-string/"/>
    <updated>2013-11-16T18:04:00+08:00</updated>
    <id>http://jqlblue.github.io/2013/11/16/pdo-mysql-escape-string</id>
    <content type="html"><![CDATA[<p>最近在项目中使用了鸟哥的yar扩展，但是在php5.2.10环境中没有安装成功，所以将php升级到了5.5。</p>

<!-- more -->


<h3>升级步骤</h3>

<ul>
<li>安装php5.5.0</li>
<li>检测代码兼容性</li>
<li>从线上服务器日志中收集最热的一百条访问日志</li>
<li>下线一台服务器，启动php5.5环境，根据日志中最热的请求进行重放</li>
<li>检测服务器日志进行改进</li>
</ul>


<p>升级过程很顺利，但是上线后在日志中发现如下信息：</p>

<pre><code>mysql_escape_string(): This function is deprecated; use mysql_real_escape_string() instead
</code></pre>

<p>于是顺手修复上线。鉴于最近没怎么写代码，手有点生，先发布到了测试环境测试没问题才上线。</p>

<p>就在去茶水间接了一杯水的当儿，运营反馈说线上页面显示异常。于是马上回滚代码。</p>

<p>问题代码如下：</p>

<pre><code>$db = getDb();
$a = mysql_real_escape_string($keyword);
$sql = 'select info from table where keyword = ' . $a;
$res = $db-&gt;getRow($sql);
</code></pre>

<p>通过调试，发现：</p>

<pre><code>$keyword在mysql_real_escape_string处理之后，变成了false，所以在进行后面的查询时获取不到相应结果，页面就异常了。
</code></pre>

<p>再进一步调试发现：</p>

<pre><code>getDb使用的是pdo。
$dbh = new PDO('mysql:host=xxx;port=xxx;dbname=xxx', 'xxx', 'xxx');
</code></pre>

<p>于是原因浮出水面</p>

<pre><code>1 在使用string mysql_real_escape_string时没有指定link_identifier
2 所以会去找使用mysql_connect()打开的最后一个连接
3 使用的是pdo，没有找到相关连接。于是尝试使用不带任何参数的mysql_connect()去建立一个连接来使用
4 本机没有mysql server，自然建立连接失败。于是发生错误，并产生警告信息（E_WARNING）
5 服务器上设置的错误报告等级已经屏蔽了E_WARNING，所以也没有监控到相关错误
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在fedora上安装fcitx输入法和云拼音]]></title>
    <link href="http://jqlblue.github.io/2013/10/26/fcitx-fedora/"/>
    <updated>2013-10-26T12:30:00+08:00</updated>
    <id>http://jqlblue.github.io/2013/10/26/fcitx-fedora</id>
    <content type="html"><![CDATA[<p>从fedora18开始，ibus感觉渐渐不如以前好用了，尤其是在emacs下使用的时候，经过死机。restart input method是家常便饭。</p>

<p>一次发现同事的ubuntu上在使用google输入法，让我眼前一亮。但是在64位的
fedora19上没有配置成功。于是尝试了下fcitx输入法，特此记录。</p>

<!-- more -->


<h3>安装步骤</h3>

<figure class='code'><figcaption><span>fcitx install step </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>yum install fcitx.x86_64
</span><span class='line'>yum install fcitx-configtool.x86_64
</span><span class='line'>yum install fcitx-gtk3.x86_64
</span><span class='line'>yum install fcitx-cloudpinyin.x86_64
</span><span class='line'>yum install fcitx-table-chinese.noarch
</span><span class='line'>yum intall fcitx-qt4.x86_64
</span></code></pre></td></tr></table></div></figure>


<h3>配置</h3>

<p>编辑~/.bashrc，添加：</p>

<pre><code>export GTK_IM_MODULE=fcitx
export QT_IM_MODULE=fcitx
export XMODIFIERS="@im=fcitx"
</code></pre>

<p>重启系统或者logout，使之生效。</p>

<pre><code>如果将im_module设置为xim，系统重启时可能会造成应用程序卡死。
此时可以通过键盘快捷键“CTRL+ALT+F2”，切换成tty2，
通过console模式登录系统杀死fcitx进程，再切回X window，或者直接重启。
</code></pre>

<h3>相关设置</h3>

<p>如下图所示：</p>

<pre><code>1. 在“input method”Tab，可以添加或者删除输入法
2. “Global Config”Tab，主要用于设置相关快捷键
3. “Appearance”列用于设置输入法弹出框的显示界面
4. 点击“Addon”Tab，通过Cloud Pinyin可以设置云拼音。即可以将谷歌拼音，搜狗，百度，QQ输入法的内容合并进来。
   下图的设置，是当输入第二个词的时候，将云拼音的结果合并到第二个位置。
</code></pre>

<p><img src="http://jqlblue.github.io/images/fcitx_config.png" title="'fcitx_config images'" >
<img src="http://jqlblue.github.io/images/fcitx_config_cloud_pinyin.png" title="'fcitx_config_cloud_pinyin images'" ></p>

<p>reference：</p>

<blockquote><p><a href="https://wiki.archlinux.org/index.php/Fcitx">Fcitx</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[九月[september]]]></title>
    <link href="http://jqlblue.github.io/2013/08/31/september/"/>
    <updated>2013-08-31T09:09:00+08:00</updated>
    <id>http://jqlblue.github.io/2013/08/31/september</id>
    <content type="html"><![CDATA[<h3>出生</h3>

<p>九月份，我出生来到了这个世界。</p>

<p>然后一天天地长大。</p>

<p>我遇到了很多人很多事；有好心的老师和同学，当然也有不好的人和事，但是一
切终究过去。</p>

<!-- more -->


<h3>北上</h3>

<p>九月份，我选择北上帝度。</p>

<p>拎着老爸买的行李箱，和老爸张罗给找的同伴一起出发。
至今，即将十年。</p>

<p>当时应该是满怀着梦想。在近20个小时的路途中，年轻的身板没有露出一点疲倦
的姿态。就这么一路坐着过去，貌似一眼就没合。结果在老爸同学的小车上睡着
了，第一次路过天安门时，我都没瞟一眼。</p>

<h3>漂</h3>

<p>梦想很丰满，现实很骨感。</p>

<p>四年的光阴，在弹指一挥之间，就如白驹过隙，叟地就结束了。然后就成为了码
农。</p>

<p>有时候想想，感觉还是子承父业。</p>

<p>老爸用转盖楼，我用代码搭建起来的互联网服务。</p>

<p>从领到第一份工资，到从这个公司离职，又那个公司继续上班。感觉自己渐渐
地迷失了。唯一留下的，是对coding的热爱，抑或是对社会的逃避。</p>

<p>相对于人而言，计算机是简单而且忠诚的。</p>

<p>只要你足够了解它，你想让它做的事情，它就一定能为你做到。而人不一样，就
算把和心和肝都掏出来给他/她。他/她也不一定会领你的情。</p>

<p>人有自主的思维，你无法完全控制他/她的那块cpu（写到这里，突然发现我可能
真的有些大男子主义）。</p>

<p>internet的出现，本来是要加强人与人之间的联系。但是随着网络基础建设的升
级以及智能设备的普及。每个人的确都成了网民（互联网这张大网上的一个独立
个体），每天趴在这张大网上。</p>

<p>有些时候，我蛮怀念大学的日子。很穷，很多东西都买不起。但是毕竟还有梦想。
还有燃烧的青春。那年轻的冲满荷尔蒙的身体，可以在网吧通宵后接着去教室上
课（课上是否呼呼大睡被老师批评另说），可以在傍晚的操场上轻松地跑完800
米，还可以很多。。。。</p>

<p>而现在，依然很多东西都买不起。而且，光鲜的外表下，好多器官或许都开始老化或者已经不能正常工作。哪天
的一个突发事件，就会让小心脏嘎嘣停止。</p>

<h3>厦门</h3>

<p>还是九月，我去了厦门。那是一个很干净的城市。</p>

<hr />

<p>又要到九月了。
突然发现九月对于我，是一个值得回忆和期待的数字。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[an introduction to systemtap]]></title>
    <link href="http://jqlblue.github.io/2013/08/18/an-introduction-to-systemtap/"/>
    <updated>2013-08-18T10:07:00+08:00</updated>
    <id>http://jqlblue.github.io/2013/08/18/an-introduction-to-systemtap</id>
    <content type="html"><![CDATA[<p>就像它的名字system（系统）tap（窃听），systemtap提供了底层的支持，以简化系统在运行时的信息收集（包括用户态和内核态的信息）。通过对收集到的信息进行分析，可以帮忙我们识别潜在的性能原因和功能问题。</p>

<!-- more -->


<pre><code>SystemTap is a tool for the Linux Operating System
that allows developers and system administrators to deeply investigate
the behavior of the kernel and even user space applications
in order to discover error conditions, performance issues,
or just to understand how the system works, similarly to DTrace.

systemtap不会直接告诉你程序哪里出了问题。但是在你对代码熟悉的情况下，可以用一成的功力使出七八成的效果
</code></pre>

<p>以往在收集这些信息时，我们需要添加检测点，重新编译，安装，重启使之生效。
挺没意思的。。。</p>

<p>使用systemtap就不需要了，我们只要编写相关脚本，并让systemtap的命令
行接口stap（systemtap script translator/driver）进行调用就可以收集到用
户空间和内核空间的相关信息。</p>

<p>通过编写SystemTap脚本，我们就可以很容易地收集甚至篡改系统数据，这是普
通的linux系统工具所做不到的。</p>

<h3>相关背景知识</h3>

<p>在Solaris系统上，有一个大名鼎鼎的动态跟踪工具
<a href="http://en.wikipedia.org/wiki/DTrace">Dtrace</a>，这一个相当棒的工具（从
2001年10月开始开发，在2005年1月首次发布），曾
荣获《华尔街杂志》
<a href="https://blogs.oracle.com/swan/date/20070307">2006技术创新大奖中的金奖</a>
，和ZFS文件系统一样，DTrace一直都因版权问题而无法移植到Linux上，但
Oracle（SUN公司被Oracle收购）在2012年2月宣布发布DTrace for Linux beta
版，即将Solaris操作系统的动态跟踪工具移植到他们的Unbreakable
Enterprise Kernel(2.6.39)内，也就是说Linux人员终于也可以使用DTrace了。</p>

<p>在2005年1月开始，开源社区为linux操作系统开发了基于GPL许可的systemtap。</p>

<p>目前一般的Linux发行版，比如Fedora、OpenSuse、CentOS等，已经包含有systemtap的完整支持了。</p>

<h3>与其他trace工具比较</h3>

<ul>
<li>Dtrace：
dtrace不用多说了，systemtap的开发，就是用来替代dtrace的，但是他们还
是有以下几个明确的差异：

<ol>
<li>Dtrace不允许你任意地注入c代码，即在运行时修改系统数据，通过-g选项</li>
<li>Dtrace脚本是以虚拟机字节码的形式在内核中进行解释，而systemtap脚本
则是以本地二进制代码的形式被进行加载</li>
</ol>
</li>
<li>strace：
strace工作于用户态，只能用于处理系统调用</li>
<li>ltrace：
ltrace工作于用户态，只能用于处理用户态的函数</li>
<li>gdb：
gdb也工作于用户态，它的目标是进行交互式的调试</li>
</ul>


<p>更多信息请参见：<a href="http://sourceware.org/systemtap/wiki/SystemtapDtraceComparison">SystemtapDtraceComparison</a></p>

<p>而systemtap作为一个通用工具，通过追踪（tracing），可以了解：</p>

<pre><code>在一段时间内，某进程执行了哪些系统调用以及次数
一个函数执行了多长时间
进程函数调用栈并使用相关工具生成火焰图 (Flame Graph)
甚至可以使用systemtap脚本进行任意发挥
</code></pre>

<p>reference:
<a href="http://sourceware.org/systemtap/langref/SystemTap_overview.html#SECTION00021000000000000000">http://sourceware.org/systemtap/langref/SystemTap_overview.html#SECTION00021000000000000000</a>
<a href="http://raisama.net/talks/fisl10/kernel-hacking/stap.pdf">http://raisama.net/talks/fisl10/kernel-hacking/stap.pdf</a>
<a href="http://cheeselee.fedorapeople.org/systemtap-robin-20130817.pdf">http://cheeselee.fedorapeople.org/systemtap-robin-20130817.pdf</a>
<a href="http://agentzh.org/misc/slides/yapc-na-2013-flame-graphs.pdf">http://agentzh.org/misc/slides/yapc-na-2013-flame-graphs.pdf</a>
<a href="http://www.linuxfoundation.jp/jp_uploads/seminar20090225/obata.pdf">http://www.linuxfoundation.jp/jp_uploads/seminar20090225/obata.pdf</a>
<a href="http://dtrace.org/blogs/brendan/2011/10/15/using-systemtap/">http://dtrace.org/blogs/brendan/2011/10/15/using-systemtap/</a>
<a href="http://lenky.info/2013/02/04/systemtap%E5%88%9D%E8%AF%95%E7%94%A8/">http://lenky.info/2013/02/04/systemtap%E5%88%9D%E8%AF%95%E7%94%A8/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[php 5.5 upgrade guide]]></title>
    <link href="http://jqlblue.github.io/2013/08/10/php-5-dot-5-upgrade-guide/"/>
    <updated>2013-08-10T09:41:00+08:00</updated>
    <id>http://jqlblue.github.io/2013/08/10/php-5-dot-5-upgrade-guide</id>
    <content type="html"><![CDATA[<p>前一阵子经常收到应用服务器的报警。登录服务器查看日志，netstat，strace
看不出问题（道行不够）。然后restart之后，一切又都正常。</p>

<p>面对打着补丁的5.2，我们决定升级到php5.5</p>

<!-- more -->


<h3>The reason</h3>

<p>左右事物发展变化的，除了自身的能力和品质，有时跟环境的变迁，也有着莫大
的关系。</p>

<p>作为一个在开发一线的互联网从业人员。优化，重构，这可能是我们要经常提及
的两个话题。</p>

<p>通过监控，度量，找出系统中那20%的瓶颈问题，一般就能让系统的性能有很大
的提升。这种优化算作自身能力的提升。</p>

<p>一个在线上运行的系统，实际上还依赖与服务器，带宽等硬件环境；操作系统，
程序编译器或者解释器等软件环境。这些环境，也在更新优化。</p>

<p>在自身能力不变的情况化，如果这些环境得以更新优化，我们的系统也会跑地更
快。</p>

<p>就像nike，同样的人，穿着nike会有飞一般的感觉。</p>

<h3>Step</h3>

<p>先引用鸟哥在 <a href="http://www.thinkinlamp.com/">thinkinlamp</a>演讲内容：
<img src="http://jqlblue.github.io/images/php-5.5-prefermance.png" title="'php-5.5-prefermance 'images'" ></p>

<p>理论上，从php5.2升级到php5.5，性能最少能提升30%。</p>

<p>当然，升级有风险，操作需谨慎。</p>

<p>下面是升级步骤：</p>

<h5>1. 安装php5.5</h5>

<figure class='code'><figcaption><span>php-5.5.0-install.sh </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">PHP_VERSION</span><span class="o">=</span>5.5.0
</span><span class='line'>wget -c http://www.php.net/get/php-<span class="k">${</span><span class="nv">PHP_VERSION</span><span class="k">}</span>.tar.gz/from/this/mirror
</span><span class='line'>tar zxvf php-<span class="k">${</span><span class="nv">PHP_VERSION</span><span class="k">}</span>.tar.gz
</span><span class='line'><span class="nb">cd </span>php-<span class="k">${</span><span class="nv">PHP_VERSION</span><span class="k">}</span>
</span><span class='line'><span class="nv">PHP_PREFIX</span><span class="o">=</span>/usr/local/php-<span class="k">${</span><span class="nv">PHP_VERSION</span><span class="k">}</span>
</span><span class='line'>./configure <span class="se">\</span>
</span><span class='line'>--prefix<span class="o">=</span><span class="k">${</span><span class="nv">PHP_PREFIX</span><span class="k">}</span> <span class="se">\</span>
</span><span class='line'>--with-config-file-path<span class="o">=</span><span class="k">${</span><span class="nv">PHP_PREFIX</span><span class="k">}</span>/etc <span class="se">\</span>
</span><span class='line'>--disable-debug <span class="se">\</span>
</span><span class='line'>--enable-inline-optimization <span class="se">\</span>
</span><span class='line'>--disable-all <span class="se">\</span>
</span><span class='line'>--enable-fpm <span class="se">\</span>
</span><span class='line'>--enable-libxml <span class="se">\</span>
</span><span class='line'>--enable-session <span class="se">\</span>
</span><span class='line'>--enable-xml <span class="se">\</span>
</span><span class='line'>--enable-hash <span class="se">\</span>
</span><span class='line'>--enable-mbstring <span class="se">\</span>
</span><span class='line'>--with-layout<span class="o">=</span>GNU <span class="se">\</span>
</span><span class='line'>--enable-filter <span class="se">\</span>
</span><span class='line'>--with-pcre-regex <span class="se">\</span>
</span><span class='line'>--with-zlib <span class="se">\</span>
</span><span class='line'>--enable-json <span class="se">\</span>
</span><span class='line'>--enable-mysqlnd <span class="se">\</span>
</span><span class='line'>--enable-pdo <span class="se">\</span>
</span><span class='line'>--with-mysql<span class="o">=</span>mysqlnd <span class="se">\</span>
</span><span class='line'>--with-mysqli<span class="o">=</span>mysqlnd <span class="se">\</span>
</span><span class='line'>--with-pdo-mysql<span class="o">=</span>mysqlnd <span class="se">\</span>
</span><span class='line'>--enable-simplexml <span class="se">\</span>
</span><span class='line'>--enable-dom <span class="se">\</span>
</span><span class='line'>--enable-phar <span class="se">\</span>
</span><span class='line'>--enable-tokenizer <span class="se">\</span>
</span><span class='line'>--enable-posix <span class="se">\</span>
</span><span class='line'>--enable-xmlwriter <span class="se">\</span>
</span><span class='line'>--enable-xmlreader <span class="se">\</span>
</span><span class='line'>--with-curl <span class="se">\</span>
</span><span class='line'>--with-iconv <span class="se">\</span>
</span><span class='line'>--with-mcrypt <span class="se">\</span>
</span><span class='line'>--enable-ctype <span class="se">\</span>
</span><span class='line'>--enable-opcache
</span><span class='line'>make
</span><span class='line'>make install
</span></code></pre></td></tr></table></div></figure>


<p>完整脚本可参见：
<a href="https://gist.github.com/jqlblue/6198630">在centos5上安装php5.5.0</a></p>

<p>备注：</p>

<pre><code>1. 安装php时，要指定安装目录(prefix)，以备出现问题时可以及时回滚
2. 安装扩展时同样需要注意，不要覆盖其他版本的扩展
   1) 使用绝对路径执行phpize
   2) 在configure时指定php5.5目录下的php-config，--with-php-config
   3) 编译扩展需要的lib库时，也要指定版本和安装目录
</code></pre>

<h5>2. php代码语法兼容性检测</h5>

<p>php每次大版本的升级，都会废弃一些函数，这些函数在新版本的php中使用的话，
就会报致命错误（Fatal error）。通过下面的方法，可以检测这些场景。</p>

<figure class='code'><figcaption><span>check-php5.5-compatibility.sh </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/bin/sh</span>
</span><span class='line'><span class="c">#use sh ./check-php-compatibility.sh /path/code</span>
</span><span class='line'><span class="k">if</span> <span class="o">[[</span> <span class="nv">$1</span> !<span class="o">=</span> <span class="s1">&#39;&#39;</span> <span class="o">]]</span>;<span class="k">then</span>
</span><span class='line'><span class="k">   </span><span class="nv">SOURCE_ROOT</span><span class="o">=</span><span class="nv">$1</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'><span class="k">   </span><span class="nv">SOURCE_ROOT</span><span class="o">=</span><span class="s1">&#39;/path/code/src&#39;</span>
</span><span class='line'><span class="k">fi</span>
</span><span class='line'><span class="nv">PHP_BIN</span><span class="o">=</span><span class="s1">&#39;/usr/local/php-5.5.0/bin/php&#39;</span>
</span><span class='line'><span class="k">for </span>file in <span class="k">$(</span>find <span class="k">${</span><span class="nv">SOURCE_ROOT</span><span class="k">}</span> -type f -iname <span class="s1">&#39;*.php&#39;</span><span class="k">)</span>; <span class="k">do</span>
</span><span class='line'>    <span class="k">${</span><span class="nv">PHP_BIN</span><span class="k">}</span> -d <span class="nv">error_reporting</span><span class="o">=</span>E_ALL -l <span class="nv">$file</span> | grep -v <span class="s1">&#39;No syntax errors detected&#39;</span>
</span><span class='line'><span class="k">done</span>
</span></code></pre></td></tr></table></div></figure>


<p>更多的信息，请参见 <a href="http://codeascraft.com/2012/08/10/static-analysis-for-php/">static-analysis-for-php</a></p>

<h5>3. 从服务器上收集请求情况</h5>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>cat access.log | awk -F <span class="s2">&quot;[ ?]&quot;</span> <span class="s1">&#39;{urls[$7]++} END {for(key in urls)print urls[key],&quot;\t&quot;,key}&#39;</span> | sort -nr
</span></code></pre></td></tr></table></div></figure>


<h5>4. 通过收集的请求url进行测试</h5>

<p>对于get方式的url请求，直接wget或者curl就好。</p>

<p>对于post方式的curl请求，需要用curl模拟post请求进行提交。同时需要在
webserver日志中记录post请求参数。</p>

<h5>5. 查看webserver的错误日志，进行改进</h5>

<h3>Improve</h3>

<p>上线后通过在nginx的access log中开启记录upstream_time和request_time进行
统计，php-5.5.0环境下接口的响应速度较5.2.5环境提升了(0.00487559-0.00366027)/0.00487559=24.9%</p>

<pre><code>php-5.5.0
total_request_time:196416 total_upstream_time:1122.52 total_request:306678 avg_requst_time:0.640464 avg_upstream_time:0.00366027

php-5.2.5
total_request_time:200400 total_upstream_time:1498.65 total_request:307378 avg_requst_time:0.651966 avg_upstream_time:0.00487559
</code></pre>

<p>统计脚本</p>

<pre><code>cat access.log | grep '/api/getInfo' | awk -F ')"' '{print $2}' | grep -v ' -' | awk 'BEGIN{_request=0;_upstream=0;_i=0}{_request+=$2;_upstream+=$3;_i+=1}END{print "total_request_time:"_request" total_upstream_time:"_upstream" total_request:"_i" avg_requst_time:"_request/_i" avg_upstream_time:"_upstream/_i}'
</code></pre>

<p>另外，做了php5.3.10和php.5.5.0的压测比较</p>

<pre><code>php5.3.10
Speed=30441 pages/min, 1224275 bytes/sec.
Requests: 30441 susceed, 0 failed.

php5.5.0
Speed=42514 pages/min, 1727526 bytes/sec.
Requests: 42514 susceed, 0 failed.
PHP 5.5 vs 5.3 improve 39% (708-507)/507=0.3964497041
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[移动应用无线抓包指南]]></title>
    <link href="http://jqlblue.github.io/2013/08/04/guide-of-packet-mobile-capture/"/>
    <updated>2013-08-04T11:41:00+08:00</updated>
    <id>http://jqlblue.github.io/2013/08/04/guide-of-packet-mobile-capture</id>
    <content type="html"><![CDATA[<h3>引子</h3>

<p>如果将互联网比喻成纵横交错的铁道，那由c，h，o等元素组成的人和物则被打
包装进一节节车厢，然后组成一列火车在铁道上穿行。手机，笔记本等终端，可
以理解为车站，每天都有很多人进进出出。</p>

<p>有一天，你突然发现车站少了个东西，或者想了解下都有些什么人出站，什么人
入站。这时，我们就需要抓包（Capturing Packages）。</p>

<p>继续以铁路为例。一般情况下，我们只要在装载这人和物的火车入站和出站的时候设置关卡，
进行检查就可以了。</p>

<!-- more -->


<p>但突然有天发现某个车站是德国人给造的，我们要私自设置
关卡的话，就没有保修了。</p>

<p>实际上，我们私自设置关卡也无防。现在的东西更新换代太快，等坏的时候，直
接入手一个新的，或许比保修还经济呢。</p>

<p>等要动手的时候，想起这个德国制造，还是有些不忍。</p>

<p>在你正想点燃那支兰州的当儿，想起西边有你表哥建造的一个车站。所以可以代
理一把，让要进出的火车先去你表哥的车站。</p>

<h3>抓包的三种方式</h3>

<p>至此，我们可以看到抓包的三种方式：</p>

<pre><code>1. 本地抓包
2. 远程服务器抓包
3. 代理抓包
</code></pre>

<h3>本地抓包</h3>

<p>不管使用手机还是平板，进出的数据包，都会经过该设备的网卡。如果你的设备
已经root，可以使用tcpdump将抓包数据存成xxx.pcap，然后在电脑上就可以使
用wireshark进行查看。也可以使用webview
<a href="http://www.cloudshark.org">cloudshark</a>。
更多信息请上google查询。</p>

<h3>远程服务器抓包</h3>

<p>从设备上发出的请求，在网络通畅的情况下，最终都会达到某个服务器。所以我
们可以在远程服务器上抓包。可以使用tcpdump，但是我更推荐ngrep(network
grep)。</p>

<p>在centos上，直接</p>

<pre><code>yum install ngrep
</code></pre>

<p>下面是一些简单示例</p>

<pre><code>ngrep -t -d any port 25
ngrep -q -W byline "(GET|POST).*"
</code></pre>

<p>更多用法请查看</p>

<pre><code>man ngrep
</code></pre>

<h3>代理抓包</h3>

<p>开始废话说地有点多，这才是本文的重点。</p>

<p>设置代理，就是要在你的移动终端和某台电脑之间网络互通的情况下：</p>

<pre><code>1. 在电脑上设置代理
2. 移动终端上网的时候连接这个代理
</code></pre>

<p>就可以在电脑上进行抓包了（<em>把一个陌生的概念转行成一个很熟悉的概念，
fiddle抓包嘛，码农应该都知道</em>）。</p>

<p>我们以移动终端与要进行代理抓包的电脑之间网络不通的情况为例进行说明（<em>如
果电脑和移动终端可以连接同一wifi，只要按照设置代理的部分进行操作就好</em>）</p>

<ul>
<li><p>在电脑上创建无线网络</p>

<p>  我们使用360随身wifi在电脑上创建无线网络。要购买的话，现阶段需要时常关注
  <a href="http://wifi.360.cn/">官网</a>,因为不定期会在京东开启抢购。安装非常简
  单，插入usb接口，就自动创建好无线网络了（目前只支持windows系统）</p>

<p>  <img src="http://jqlblue.github.io/images/360wifi_1.png" title="'360 wifi images'" >
  <img src="http://jqlblue.github.io/images/360wifi_2.png" title="'360 wifi images'" >
  <img src="http://jqlblue.github.io/images/360wifi_3.png" title="'360 wifi images'" ></p></li>
<li><p>在电脑上用fiddle设置代理</p>

<p>  <img src="http://jqlblue.github.io/images/360wifi_fiddle.png" title="'360 wifiproxy fidlle images'" ></p></li>
<li><p>修改手机上的网络设置，并设置代理</p>

<p>  <img src="http://jqlblue.github.io/images/360wifi_proxy_1.png" title="'360 wifi mobile network" >
  <img src="http://jqlblue.github.io/images/360wifi_proxy_2.png" title="'360 wifi mobile network" >
  <img src="http://jqlblue.github.io/images/360wifi_proxy_3.png" title="'360 wifi mobile network" ></p>

<p>  代理服务器的ip可以通过在电脑上查看网络连接获取，代理的端口就是在
  fiddle中设置的&#8221;listen on port&#8221;</p>

<p>  <img src="http://jqlblue.github.io/images/360wifi_proxy_ip.png" title="'360 wifi mobile network" ></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[broken pipe in php cli]]></title>
    <link href="http://jqlblue.github.io/2013/08/03/broken-pipe-in-php-cli/"/>
    <updated>2013-08-03T20:08:00+08:00</updated>
    <id>http://jqlblue.github.io/2013/08/03/broken-pipe-in-php-cli</id>
    <content type="html"><![CDATA[<p>下周打算把服务器上的php升级到5.5，综合老大的建议，计划按这个步骤进行：</p>

<hr />

<ul>
<li>下线一台服务器，另起目录安装php5.5</li>
</ul>


<p>安装过程与php5.3差不多，要开启zend opcache的话，需要在
configure时&mdash;enable-opcache。在php.ini中配置时，需要以zend_extension的
形式加载。</p>

<!-- more -->


<ul>
<li>从服务器访问日志中统计最近有请求的接口，按请求次数从大大小排序</li>
</ul>


<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>cat access_log | awk <span class="s1">&#39;{print $7}&#39;</span> | awk -F <span class="s2">&quot;?&quot;</span> <span class="s1">&#39;{print $1}&#39;</span> | sort | uniq -c | sort -nr
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>通过已统计的接口列表（通过第二步产生），从访问日志中查询相关请求地
 址（包括相关参数）</li>
</ul>


<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>access_log | grep  <span class="s1">&#39;/api/test&#39;</span> | head -n 1
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>绑定hosts，根据请求地址列表进行访问，观察web server和php的相关日志</li>
</ul>


<hr />

<p>进行到第三步，就卡住了。：（</p>

<p>“cat access_log | grep  &lsquo;/api/test&rsquo; | head -n 1”这条命令在shell下执行
没有问题，但是如果用php的shell_exec运行，就会出现 “grep: writing
output: Broken pipe”。</p>

<p>一顿google之后，遇到这篇文章Python中的SIGPIPE信号。对作者的示例代码做
了下加工后，发现一切正常了，修改后的python代码如下</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">subprocess</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">signal</span>
</span><span class='line'><span class="k">def</span> <span class="nf">reset_sigpipe</span><span class="p">():</span>
</span><span class='line'>    <span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGPIPE</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">SIG_DFL</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">output</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">(</span><span class="s">&quot;cat access_log | grep  &#39;/api/test&#39; | head -n 1&quot;</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">preexec_fn</span><span class="o">=</span><span class="n">reset_sigpipe</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span> <span class="n">output</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是我是要用php来做这件事，下面是php相关代码</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="o">&lt;?</span><span class="nx">php</span>
</span><span class='line'><span class="nv">$source</span> <span class="o">=</span> <span class="s1">&#39;./source_url.txt&#39;</span><span class="p">;</span>
</span><span class='line'><span class="nv">$dest</span> <span class="o">=</span> <span class="s1">&#39;./dest_url.txt&#39;</span><span class="p">;</span>
</span><span class='line'><span class="nv">$res</span> <span class="o">=</span> <span class="nb">file</span><span class="p">(</span><span class="nv">$source</span><span class="p">);</span>
</span><span class='line'><span class="nb">pcntl_signal</span><span class="p">(</span><span class="nx">SIGPIPE</span><span class="p">,</span> <span class="nx">SIG_DFL</span><span class="p">);</span>
</span><span class='line'><span class="nb">file_put_contents</span><span class="p">(</span><span class="nv">$dest</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">);</span>
</span><span class='line'><span class="k">foreach</span> <span class="p">(</span><span class="nv">$res</span> <span class="k">as</span> <span class="nv">$row</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nv">$row</span> <span class="o">=</span> <span class="nx">trim</span><span class="p">(</span><span class="nv">$row</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">strpos</span><span class="p">(</span><span class="nv">$row</span><span class="p">,</span> <span class="s1">&#39;http://&#39;</span><span class="p">)</span> <span class="o">!==</span> <span class="k">false</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nv">$command</span> <span class="o">=</span> <span class="s2">&quot;cat access_log | grep  &#39;</span><span class="si">{</span><span class="nv">$row</span><span class="si">}</span><span class="s2">&#39; | head -n 1 | awk &#39;{print </span><span class="se">\$</span><span class="s2">6</span><span class="se">\&quot;</span><span class="s2"> </span><span class="se">\&quot;\$</span><span class="s2">7}&#39; | awk -F &#39;</span><span class="se">\&quot;</span><span class="s2">&#39; &#39;{print $2}&#39; | awk &#39;{print $1</span><span class="se">\&quot;</span><span class="s2"> http://test.api.com</span><span class="se">\&quot;</span><span class="s2">$2}&#39;&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="nv">$check</span> <span class="o">=</span> <span class="nb">system</span><span class="p">(</span><span class="nv">$command</span><span class="p">);</span>
</span><span class='line'>    <span class="nb">file_put_contents</span><span class="p">(</span><span class="nv">$dest</span><span class="p">,</span> <span class="nv">$check</span> <span class="o">.</span> <span class="nx">PHP_EOL</span><span class="p">,</span> <span class="nx">FILE_APPEND</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>和python中的signal.signal(signal.SIGPIPE, signal.SIG_DFL)一样，关键是
这句:</p>

<pre><code>pcntl_signal(SIGPIPE, SIG_DFL)
</code></pre>

<p>当php进程接收到SIGPIPE信号时，重置
为系统默认处理方式，即接收子进程的返回值。</p>

<p><strong>问题解决了，但是原因呢？</strong></p>

<p>我们再看看这行命令</p>

<pre><code>cat access_log | grep  '/api/test' | head -n 1
</code></pre>

<p>head命令在取得一行后立即退出（exit），此时pipe的读端就没了，但grep还会
继续往pipe写，此时pipe就会发送SIGPIPE信号，默认动作是终止程序。在shell
下执行时，grep收到SIGPIPE信号就退出了，所以运行没有问题。</p>

<p>但在通过php的shell_exec或者system运行为何就有问题。应该是php忽略了
SIGPIPE信号，所以grep会继续向broke pipe（读端关闭）写入，于是就出现了</p>

<pre><code>grep: writing output: Broken pipe
</code></pre>

<p>在天朝，有图也不一定是真相。所以应该是，也不一定是。废话少说，我们直接
上代码：</p>

<pre><code>$grep -r 'SIGPIPE' ./
./sapi/cli/php_cli.c:   signal(SIGPIPE, SIG_IGN); /* ignore SIGPIPE in standalone mode so
</code></pre>

<p>所以php以cli的形式运行时，会忽略SIGPIPE信号。</p>

<p>reference：</p>

<blockquote><p><a href="https://blogs.oracle.com/opal/entry/using_php_5_5_s">https://blogs.oracle.com/opal/entry/using_php_5_5_s</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[check php 5.5 compatibility]]></title>
    <link href="http://jqlblue.github.io/2013/08/03/check-php5-dot-5-compatibility/"/>
    <updated>2013-08-03T18:16:00+08:00</updated>
    <id>http://jqlblue.github.io/2013/08/03/check-php5-dot-5-compatibility</id>
    <content type="html"><![CDATA[<p>github上有个项目可以检测php5.3，5.4的兼容性，如下：
<a href="https://github.com/wimg/PHPCompatibility">https://github.com/wimg/PHPCompatibility</a></p>

<p>如果最近你想把php升级到5.5，尝试下generators和coroutines，这个应该对你
有帮助。也可以参见博文：</p>

<p><a href="http://techblog.wimgodden.be/2012/03/04/php-5-4-compatibility-checks-using-php_codesniffer/">http://techblog.wimgodden.be/2012/03/04/php-5-4-compatibility-checks-using-php_codesniffer/</a></p>

<!-- more -->


<p>第一次尝试时，可能因为php配置的问题（date.timezone），所以没有检测出任
何东西。</p>

<p>在php.ini中设置了</p>

<blockquote><p>date.timezone = Asia/Shanghai</p></blockquote>

<p>之后，发现效果不错，只是显示的行号有问题，而且检测的速度不尽人意。</p>

<p>所以我在安装完php5.5后，写了个shell脚本，用php -l来检测。内容如下：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/bin/sh</span>
</span><span class='line'><span class="nv">SOURCE_ROOT</span><span class="o">=</span><span class="s1">&#39;/path/php-code&#39;</span>
</span><span class='line'><span class="nv">PHP_BIN</span><span class="o">=</span><span class="s1">&#39;/usr/local/php-5.5/bin/php&#39;</span>
</span><span class='line'><span class="k">for </span>file in <span class="k">$(</span>find <span class="k">${</span><span class="nv">SOURCE_ROOT</span><span class="k">}</span> -type f -iname <span class="s1">&#39;*.php&#39;</span><span class="k">)</span>; <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="nv">check_syntax</span><span class="o">=</span><span class="k">$(${</span><span class="nv">PHP_BIN</span><span class="k">}</span> -l <span class="nv">$file</span> | grep -v <span class="s1">&#39;No syntax errors detected&#39;</span><span class="k">)</span>
</span><span class='line'><span class="k">done</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用方法：</p>

<blockquote><p>sh /path/check-php-compatibility.sh > check-result.txt</p></blockquote>
]]></content>
  </entry>
  
</feed>
