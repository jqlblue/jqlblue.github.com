<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: php | Debug Hacks]]></title>
  <link href="http://jqlblue.github.io/categories/php/atom.xml" rel="self"/>
  <link href="http://jqlblue.github.io/"/>
  <updated>2017-12-14T16:11:01+08:00</updated>
  <id>http://jqlblue.github.io/</id>
  <author>
    <name><![CDATA[jqlblue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[基于Opcache发布php项目]]></title>
    <link href="http://jqlblue.github.io/2017/12/14/use-opcache-to-deploy-php/"/>
    <updated>2017-12-14T11:17:00+08:00</updated>
    <id>http://jqlblue.github.io/2017/12/14/use-opcache-to-deploy-php</id>
    <content type="html"><![CDATA[<p>php的<code>Opcache</code>已经release好多年了，现在基本都是php的标配。最近看到了php创始人<code>Rasmus Lerdorf</code>的一篇<a href="http://talks.php.net/confoo16#/">talk</a>，于是有了使用php的opcache发布代码的想法。</p>

<!-- more -->


<h1>Opcache</h1>

<p><code>Opcache</code>也叫<code>Zend OPcache</code>，其前身是Zend公司开发的闭源PHP优化加速组件<code>Optimizer+</code>。于2013年3月中旬改名为<code>Opcache</code>，并开源。</p>

<p>在2013年6月发布的php5.5.0版本中，整合了<code>Opcache</code>。</p>

<p><a href="https://pecl.php.net/package/ZendOpcache">pecl</a>上的<code>Opcache</code>扩展，于2015-01-12转正。</p>

<p><code>OPcache</code>通过将 PHP 脚本预编译的字节码存储到共享内存(或者文件)中来提升 PHP 的性能， 存储预编译字节码的好处就是 省去了每次加载和解析 PHP 脚本的开销。不过<code>OPcache</code> 没有象 APC 那样的 user cache 功能。</p>

<p>{% img /images/opcache/php_lifecycle_opcache.png PHP script lifecycle %}</p>

<h1>Opcache使用</h1>

<p>php5.5及以上版本已经整合了<code>Opcache</code>，只需要在编译php时添加</p>

<pre><code>--enable-opcache --enable-opcache-file
</code></pre>

<p>即可为php添加opcache扩展，然后修改<code>php.ini</code>，主动开启<code>Opcache</code></p>

<pre><code>zend_extension="/path/opcache.so"
[opcache]
opcache.enable=1
opcache.enable_cli=1
</code></pre>

<p>之后运行php程序时，会生成<code>Opcache</code>，下次运行时可以直接加载，免去了词法分析，语法分析，以及解析php脚本花费的时间。</p>

<p><code>Opcache</code>默认存储在php进程的共享内存中，不过也可以存储到本地文件中。性能的差异大致如下：</p>

<p>{% img /images/opcache/secondary_file-based_cache.png Persistent secondary file-based cache for OPCache %}</p>

<p>看完这张图，突然有种脑洞大开的感觉。</p>

<p>发布php时，预先生成opcache-file，只发布opcache，是否可行呢？</p>

<h1>使用Opcache发布php</h1>

<p>开启<code>Opcache</code>后，可以使用<code>opcache_compile_file</code>生成php的opcache-file。涉及<code>php.ini</code>中的如下配置参数</p>

<pre><code>opcache.max_accelerated_files=20000
opcache.file_cache=/data/php/opcache
opcache.file_cache_only=0
opcache.validate_timestamps=0
opcache.save_comments=0
</code></pre>

<p>{% codeblock lang:php %}</p>

<p>function opcache_compile_files($dir) {</p>

<pre><code>foreach(new RecursiveIteratorIterator(new RecursiveDirectoryIterator($dir)) as $v) {
    if(!$v-&gt;isDir() &amp;&amp; preg_match('%\.php$%', $v-&gt;getRealPath())) {
        $file = $v-&gt;getRealPath();
        opcache_compile_file($file);
        file_put_contents($file, '');
        echo $file . "\n";
    }
}
</code></pre>

<p>}</p>

<p>opcache_compile_files(&lsquo;/path/project/foo&rsquo;);
{% endcodeblock %}</p>

<p>在命令行下执行上述脚本，即可遍历整个项目，生成对应php的opcache-file，同时会清空原php文件的内容。</p>

<p>如：</p>

<pre><code>ls /data/php/opcache/4d400aec8fadf667fabe41a87f30f7cc

/data/php/opcache/4d400aec8fadf667fabe41a87f30f7cc/path/project/app/Utility.php.bin
</code></pre>

<p>```</p>

<pre><code>1. 生成opcache-file时，需要设置opcache.file_cache_only=0
2. 需要保持原有项目的目录结构和文件 -- 内容可以清空，使opcache-file生效
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一周打造支付系统]]></title>
    <link href="http://jqlblue.github.io/2014/11/23/build-payment-system-in-one-week/"/>
    <updated>2014-11-23T14:34:00+08:00</updated>
    <id>http://jqlblue.github.io/2014/11/23/build-payment-system-in-one-week</id>
    <content type="html"><![CDATA[<p>获取食物的最佳方式就是处于食物链的顶端，以捕食该链条之下的所有动植物。不言而喻，搭建处于资金流顶端的支付系统，伴随资金的转移过程，也是积累财富的绝佳手段。</p>

<!-- more -->


<h1>一般网购流程</h1>

<p>{% img /images/payment/shopping_flow.png shopping flow %}</p>

<p>一般的网购流程如上图：</p>

<ul>
<li>商品筛选</li>
<li>将选中的商品添加到购物车（顾名思义，推着车去购物。如果只卖一个商品的话，可以省略这步）</li>
<li>确认要购买物品，去结算</li>
<li>下订单，即提交要结算物品的清单</li>
<li>网上支付该订单</li>
</ul>


<h1>支付流程</h1>

<p>{% img /images/payment/flow.jpg payment flow %}</p>

<p>一个典型的支付流程如上图。</p>

<p>用户下单时，订单系统需要和产品库交互，生成支付连接。支付系统对请求地址进行验签之后，调用第三方平台的支付接口进行支付，然后更新订单状态。在订单成功支付之后，更新产品库存信息。</p>

<p>属于支付系统的功能有：</p>

<ul>
<li>请求参数验签</li>
<li>第三方支付接口对接</li>
<li>订单系统对接</li>
</ul>


<blockquote><p>只要完成与第三方支付接口的对接，即可解决搭建支付系统中最难啃的一块硬骨头。</p></blockquote>

<h1>第三方支付平台</h1>

<p>目前比较流行的第三方支付平台主要有：</p>

<ul>
<li>支付宝</li>
<li>财付通</li>
<li>快钱</li>
<li>网银在线</li>
<li>微信支付</li>
</ul>


<p>对于网银支付，可以调用银联的接口，或者直接对接银行（可以降低手续费，支持大额等个性化支付方法。但是实现成本较高）。</p>

<p>虽然支付宝的手续费不是最实惠的，但是支付宝本身对接了个大银行的网银支付，而我们的目标是一周打造支付系统，当然选择最省事的。</p>

<p>对接支付宝支付接口的流程如下：</p>

<p>{% img /images/payment/zhifubao.jpg 支付宝对接 %}</p>

<p>完成<code>技术集成</code>之前的工作，理论上需要8-10个工作日，所以需要提前申请。</p>

<p>最好找商务部的同事出马，不要怕麻烦boss。有问题，及时向组织反馈。</p>

<h1>支付宝接口</h1>

<p>与支付宝接口的交互流程如下</p>

<p>{% img /images/payment/zhifubao_flow.jpg 支付宝接口交互流程  %}</p>

<p>支付宝提供的sdk，主要包含如下文件</p>

<p><code>
alipay_core.function.php -- 支付宝接口公用函数，是请求、通知返回两个文件所调用的公用函数核心处理文件
alipay_md5.function.php  -- MD5加密
alipay_notify.class.php  -- 支付宝通知处理类，处理支付宝各接口通知返回
alipay_submit.class.php  -- 支付宝各接口请求提交类，构造支付宝各接口表单HTML文本，获取远程HTTP数据
</code></p>

<p><em>要调用的方法</em></p>

<ul>
<li>提交订单时，调用<code>alipay_submit.class.php</code>中的<code>buildRequestUrl</code>方法，同时，需要注册通知回调<code>return_url</code>和<code>notify_url</code>。</li>
</ul>


<p>其中：</p>

<pre><code>return_url是同步回调，一般用于在支付成功后，调转至支付成功页。
notify_url是异步回调，一般用于更新订单状态等等（支付宝有相关队列服务运行异步回调，回调失败后，会以不定的间隔进行重试）。
</code></pre>

<ul>
<li>在通知回调时，都需要调用<code>alipay_notify.class.php</code>中的<code>verifyReturn</code>验证回调的合法性。</li>
</ul>


<h1>ssl证书</h1>

<p>俗话说，没有买卖就没有杀戮。凡是涉及利益的地方，就不会很安全。使用采用http进行数据通讯，难免发生如下问题：
{% img /images/payment/http_flow.jpg 中间人攻击 %}</p>

<p>但是换成https，会有如下好处：</p>

<p>{% img /images/payment/https_2.jpg http ssl %}</p>

<p>{% img /images/payment/https_3.jpg https flow %}</p>

<p>申请ssl证书，推荐数字公司使用的<a href="http://www.wosign.com/price.htm">WoSign超真 SSL</a>。</p>

<p>{% img /images/payment/ssl.jpg ssl %}</p>

<h1>请求验签</h1>

<p>请求参数签名，需要使用可逆加密算法。其中又分为：</p>

<ul>
<li>对称加解密算法</li>
<li>非对称加解密算法</li>
</ul>


<p>对称加解密算法，在加密和解密时都使用一个密钥，加解密性能较好。但安全性较低（密钥只要被拿到，就gameover）。</p>

<p>非对称加解密算法，一般使用私钥加密，公钥解密。其安全性较好（只要保存好私钥就行），但是性能较差。</p>

<p>所以可以使用对称加解密算法加密请求参数。但加解密时，不使用同一个密钥。相关密钥，通过非对称加解密算法加密后，在请求参数中传递。</p>

<p>解密流程如下：</p>

<pre><code>1. 在请求参数中获取使用非对称加解密算法加密的密钥ekey
2. 使用非对称加解密算法解密密钥ekey为dkey
3. 使用对称加解密算法和dkey，解密请求参数
</code></pre>

<h1>订单</h1>

<p>我们用一周打造的支付系统，不能是一个远在云端的架构，而要是一个可运行的系统。那么，订单自然也少不了。</p>

<p>订单是按照如下对应关系产生的：</p>

<pre><code>用户 -&gt; 商品 -&gt; 订单
</code></pre>

<p>在整个支付过程中，一般要存在两个订单号：</p>

<ul>
<li>用于在内部系统（订单，支付，个人中心）中流通的订单号 <code>order_no</code>，在每一次下单时产生。</li>
<li>用于支付的订单号 <code>pay_order_no</code>，由 <code>order_no</code> ＋ 时间戳 ＋ salt等，在每一次支付时产生。</li>
</ul>


<h1>联调部署</h1>

<p>开发阶段涉及的模块可做如下划分：</p>

<ul>
<li>产品页</li>
<li>支付页</li>
<li>支付</li>
<li>订单</li>
<li>个人中心</li>
<li>测试，部署上线</li>
</ul>


<p>衡量一个互联网的标准有：功能，交互，ui。</p>

<p>因为我们的目标是一周内打造支付，那么，优先是完成支付和订单。至于是否要在产品页添加购物车，是否要在订单支付页面保存配送地址，是否要在个人中心对接物流，以及退款等等，都可以暂时砍掉。</p>

<p>互联网产品，唯快不破。快速上线，快速迭代。</p>

<h1>The Hole</h1>

<p>开发过程中，难免会遇到不少坑，特此纪录，希望帮助有缘人。</p>

<ul>
<li>产品金额存储</li>
</ul>


<p>为了避免因退款，对账时，和银行或者第三方支付平台产生因为数据精度而舍入等问题，可以将产品金额以<code>分</code>为单位存储，前台展示时除以100。</p>

<ul>
<li>需要两个订单号</li>
</ul>


<p>支付宝等第三方平台，对订单号有验证，一个订单号只能支付一次。所以系统中需要存在两个订单号，一个用于内部系统流通，一个用于支付，每次支付时都产品一个最新的（与内部系统流通的订单号有对应关系）。</p>

<ul>
<li>权限验证</li>
</ul>


<p>下单，或者支付完成后，在个人中心等位置，一般可以查看订单状态。此时需要注意，需要增加权限验证。否则会产生平行权限安全漏洞（可查看别人的订单等信息）</p>

<ul>
<li>系统安全性</li>
</ul>


<p>在支付和个人中心等页面，因为存在前后端交互。所以需要排查，是否存在sql注入或者xss等安全漏洞。推荐<code>XSScrapy</code>和<code>SqlMap</code>。</p>

<ul>
<li>日志</li>
</ul>


<p>在整个交易过程中，需要有完善详尽的日志记录。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个使用curl请求https资源的问题排查]]></title>
    <link href="http://jqlblue.github.io/2014/05/14/a-trouble-in-request-https-in-curl/"/>
    <updated>2014-05-14T14:50:00+08:00</updated>
    <id>http://jqlblue.github.io/2014/05/14/a-trouble-in-request-https-in-curl</id>
    <content type="html"><![CDATA[<p>昨天临下班前，应客户端大牛的要求，开发了一个返回下载服务器ip列表的接口，用于在客户端指定host以解决用户下载时遭遇运营商dns劫持的问题。</p>

<p>开发时略微有少许忐忑，但测试时一切顺利，于是就轻松地回家了。</p>

<!-- more -->


<p>早上一上线代码，就收到了通过<code>sentry</code>发出的报警邮件。原以为是缓存没有及时更新的问题，立马手动进行更新。但还是没有通过接口获取到相关ip。随即回滚代码，重新上线。</p>

<h1>排查过程</h1>

<p>后来下线一台服务器进行调试时发现，在调用ops提供的接口获取ip列表时没有获取到返回数据，而相关接口是<code>https</code>的。</p>

<p>再跟踪请求资源的函数发现，相关函数没有对<code>https</code>请求做特殊处理。相关函数实现如下：</p>

<pre><code>public static function get($url, array $headers = array(), $timeout = 5)
{
    $ch = curl_init();

    curl_setopt($ch, CURLOPT_URL, $url);

    if ($headers) {
        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);
    }

    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, $timeout);
    curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);

    $content = curl_exec($ch);
    $response = curl_getinfo($ch);

    curl_close($ch);

    if ($response['http_code'] == 200) {
        return $content;
    }

    return null;
}
</code></pre>

<p>这或许就是昨天那少许忐忑的缘由。于是增加如下代码，测试通过后重新上线。</p>

<pre><code>    if (substr($url, 0, 5) == 'https') {
        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);
    }
</code></pre>

<h1>进一步排查</h1>

<p>线上的问题虽然暂时解决了，但是在问题解决之前，测试机上是正常的，这是为什么呢？</p>

<h2>在命令行运行curl排查问题</h2>

<p>在命令行使用curl请求ops的接口，其中线上服务器的运行结果如下：</p>

<pre><code>$ curl 'https://x.x.x.x/get_ips'

curl: (60) SSL certificate problem, verify that the CA cert is OK. Details:
error:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed
More details here: http://curl.haxx.se/docs/sslcerts.html
</code></pre>

<p>测试机上可以正常获取到结果。</p>

<p>然后分别查看curl的版本和curl使用的动态连接库，都没有发现差异</p>

<pre><code>$ /usr/bin/curl -V
$ type curl

/usr/bin/curl
$ ldd /usr/bin/curl
</code></pre>

<p>再查看上面的错误，发现可能是<code>https</code>证书的问题。于是添加<code>--verbose</code>参数，再次使用curl进行请求，以获取更多交互信息。</p>

<p>截取部分输出如下</p>

<pre><code>$ curl 'https://x.x.x.x/get_ips' --verbose

* About to connect() to x.x.x.x port 80
*   Trying x.x.x.x... connected
* Connected to x.x.x.x (x.x.x.x) port 80
* successfully set certificate verify locations:
*   CAfile: /etc/pki/tls/certs/ca-bundle.crt
CApath: none
* SSLv2, Client hello (1):
SSLv3, TLS handshake, Server hello (2):
SSLv3, TLS handshake, CERT (11):
SSLv3, TLS alert, Server hello (2):
SSL certificate problem, verify that the CA cert is OK. Details:
error:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed
* Closing connection #0
curl: (60) SSL certificate problem, verify that the CA cert is OK. Details:
error:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed
More details here: http://curl.haxx.se/docs/sslcerts.html
</code></pre>

<p>可见使用的证书的是<code>/etc/pki/tls/certs/ca-bundle.crt</code>。</p>

<p>使用测试机上的证书替换线上服务器的证书后，问题解决。</p>

<blockquote><p>如果没有可用的证书，可以使用如下方法：</p></blockquote>

<pre><code>$ curl http://curl.haxx.se/ca/cacert.pem -o /etc/pki/tls/certs/ca-bundle.crt
</code></pre>

<h1>问题总结</h1>

<p>在请求https的资源时，遇到证书不匹配的问题，一般的工具都有不进行https证书验证的选项，比如：</p>

<pre><code>$ wget 'https://x.x.x.x/get_ips' --no-check-certificate
$ curl 'https://x.x.x.x/get_ips' -k
</code></pre>

<p>当然，也可以在请求时指定证书，或者对使用的https ca证书进行更新。</p>

<p>reference:
[^1] <a href="http://curl.haxx.se/docs/sslcerts.html">http://curl.haxx.se/docs/sslcerts.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[php中的单例模式面面观]]></title>
    <link href="http://jqlblue.github.io/2014/04/26/singleton-pattern-in-php/"/>
    <updated>2014-04-26T20:47:00+08:00</updated>
    <id>http://jqlblue.github.io/2014/04/26/singleton-pattern-in-php</id>
    <content type="html"><![CDATA[<p>最近在面试时发现好多人都喜欢在简历中添加“熟悉各种设计模式”那一项。但也不乏对于最为简单的单例，也仅限于书本上的一点认知，所以扯一扯php中单例模式的几种使用场景。</p>

<!-- more -->


<h1>何为单例模式</h1>

<p>单例模式属于创建型的应用模式，可以确保某一个类只有一个实例。这在获取数据库，缓存服务器的连接句柄，以及获取配置信息方面非常方便。</p>

<p>使用单例模式，可以减少在一次web请求中多次连接数据库或者解析配置文件等操作对系统资源的消耗，也可以避免大量的new操作。</p>

<p>其UML结构图如下：</p>

<p>{% img /images/pattern/singleton-uml.png singleton-uml %}</p>

<p>在php中实现单例模式需要注意：</p>

<ul>
<li>需要一个静态变量保存实例</li>
<li>需要提供一个公共的静态方法，用于返回需要获取的实例</li>
<li>需要防止外部程序通过new和clone等操作产生相关实例，从而失去单例模式的意义</li>
</ul>


<h1>代码实现解析</h1>

<p>一个单例模式的php实现大致如下:
{% codeblock lang:php %}
class Singleton
{</p>

<pre><code>private static $_instance = null;

private function __construct()
{
}

public function __clone()
{
    trigger_error("clone method is not allowed.", E_USER_ERROR);
}

public static function getInstance()
{
    if (self::$_instance === null) {
        self::$_instance = new self();
    }

    return self::$_instance;
}
</code></pre>

<p>}
{% endcodeblock %}
上述代码通过<code>静态成员变量</code>保存创建的实例，通过将构造函数设置为私有的，并使用魔术方法<code>__clone</code>&ldquo;重载"clone方法以避免通过外部程序获取相关实例。</p>

<p>由于php中的静态变量包括：<code>静态全局变量</code>，<code>静态局部变量</code>，<code>静态成员变量</code>，所以也可以通过<code>静态局部变量</code>来保存创建的实例。但是在子类中获取创建的实例时，会遇到一些问题。示例如下：</p>

<h2>使用静态局部变量</h2>

<p>{% codeblock singleton-static.php lang:php %}
class Singleton
{</p>

<pre><code>private $_handle = null;

private function __construct()
{
    $this-&gt;_handle = new StdClass();
}

public function __clone()
{
    trigger_error("clone method is not allowed.", E_USER_ERROR);
}

public static function getInstance()
{
    static $_instance = null;

    if ($_instance === null) {
        $_instance = new self();
    }

    return $_instance;
}

public function getObj()
{
    return $this-&gt;_handle;
}
</code></pre>

<p>}</p>

<p>class UserModel extends Singleton
{</p>

<pre><code>public static function getUser()
{
    var_dump(self::getInstance()-&gt;getObj());
    //logic no care
}
</code></pre>

<p>}</p>

<p>class GroupModel extends Singleton
{</p>

<pre><code>public static function getGroup()
{
    var_dump(self::getInstance()-&gt;getObj());
    //logic no care
}
</code></pre>

<p>}</p>

<p>UserModel::getUser();
GroupModel::getGroup();
{% endcodeblock %}</p>

<pre><code>$ php /.singleton-static.php
object(Singleton)#2 (0) {
}
object(Singleton)#4 (0) {
}
</code></pre>

<blockquote><p>此例没有获取到唯一实例，因为局部静态变量，也就是在函数中定义的静态变量。其信息是存储在zend vm为每个函数分配的一个私有符号表中。</p></blockquote>

<p>php中当继承发生时，会进行函数的合并。UserModel中调用的，实际上是合并在UserModel中的getInstance，GroupModel中调用的，也是合并在GroupModel中的getInstance方法。</p>

<p>因为是在两个不同方法的私有符号表中获取数据，所以取到的不是同一个实例。</p>

<blockquote><p>可以将self换成parent试试</p></blockquote>

<h2>使用静态成员变量</h2>

<p>{% codeblock singleton-static-member.php lang:php %}
class Singleton
{</p>

<pre><code>private $_handle = null;

private static $_instance = null;

private function __construct()
{
    $this-&gt;_handle = new StdClass();
}

public function __clone()
{
    trigger_error("clone method is not allowed.", E_USER_ERROR);
}

public static function getInstance()
{
    if (self::$_instance === null) {
        self::$_instance = new self();
    }
    return self::$_instance;
}

public function getObj()
{
    return $this-&gt;_handle;
}
</code></pre>

<p>}</p>

<p>class UserModel extends Singleton
{</p>

<pre><code>public static function getUser()
{
    var_dump(self::getInstance()-&gt;getObj());
    //logic no care
}
</code></pre>

<p>}</p>

<p>class GroupModel extends Singleton
{</p>

<pre><code>public static function getGroup()
{
    var_dump(self::getInstance()-&gt;getObj());
    //logic no care
}
</code></pre>

<p>}
UserModel::getUser();
GroupModel::getGroup();
{% endcodeblock %}</p>

<pre><code>$ php /.singleton-static-member.php
object(Singleton)#2 (0) {
}
object(Singleton)#2 (0) {
}
</code></pre>

<blockquote><p>此时获取到了唯一实例，因为静态成员变量的信息是存储在类结构的 default_static_members 字段，为所有实例所共用。</p></blockquote>

<h1>编写一个单例的基类</h1>

<p>有时我们的项目中有个缓存类，还有数据库类，还有个文件操作类。想让这三个类都是单例的话，我们需要实现三个单例，这有点繁琐。于是我们可以创建一个单例的基类，要实现单例的类继承这个基类即可。直接上代码：</p>

<p>{% codeblock lang:php %}
&lt;?php
class Singleton
{</p>

<pre><code>private static $_instances = array();

protected function __construct()
{
}

final public function __clone()
{
    trigger_error("clone method is not allowed.", E_USER_ERROR);
}

final public static function getInstance()
{
    $c = get_called_class();

    if(!isset(self::$_instances[$c])) {
        self::$_instances[$c] = new $c;
    }

    return self::$_instances[$c];
}
</code></pre>

<p>}</p>

<p>class Cache Extends Singleton
{</p>

<pre><code>private $_handle = null;

protected function __construct()
{
    $this-&gt;_connect();
}

private function _connect()
{
    $this-&gt;_handle = new StdClass();
}

public function getHandle()
{
    return $this-&gt;_handle;
}
</code></pre>

<p>}</p>

<p>class Db Extends Singleton
{</p>

<pre><code>private $_handle = null;

protected function __construct()
{
    $this-&gt;_connect();
}

private function _connect()
{
    $this-&gt;_handle = new StdClass();
}

public function getHandle()
{
    return $this-&gt;_handle;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>reference：</p>

<p>[^1] <a href="http://www.php-internals.com/book/?p=chapt05/05-04-class-inherit-abstract">http://www.php-internals.com/book/?p=chapt05/05-04-class-inherit-abstract</a></p>

<p>[^2] <a href="http://zh.wikipedia.org/zh/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">http://zh.wikipedia.org/zh/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F</a></p>

<p>[^3] <a href="http://www.phptherightway.com/pages/Design-Patterns.html">http://www.phptherightway.com/pages/Design-Patterns.html</a></p>

<p>[^4] <a href="http://rancoud.com/read-phps-opcode/">http://rancoud.com/read-phps-opcode/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何静态编译php]]></title>
    <link href="http://jqlblue.github.io/2014/04/09/statically-compile-php/"/>
    <updated>2014-04-09T18:13:00+08:00</updated>
    <id>http://jqlblue.github.io/2014/04/09/statically-compile-php</id>
    <content type="html"><![CDATA[<p>有些时候，我们写了一个php脚本，但是对方的服务器上没有php环境。</p>

<p>这时，我们可以通过静态方式编译php，并将相关扩展一起打包进php可执行文件，然后在运行脚本时指定php binary。</p>

<!-- more -->


<p>安装步骤如下：</p>

<h1>准备源文件</h1>

<p><code>
wget -c http://www.php.net/get/php-5.5.11.tar.gz/from/this/mirror
tar zxvf php-5.5.11.tar.gz
wget http://pecl.php.net/get/redis-2.2.5.tgz
tar xvf redis-2.2.5.tgz
mv redis-2.2.5 php-5.5.11/ext/redis
</code></p>

<h1>配置</h1>

<h2>重新生成configure</h2>

<p><code>
cd php-5.5.11
rm -f ./configure
./buildconf --force
</code></p>

<h2>configure</h2>

<p><code>
./configure LDFLAGS=-static \
--prefix=/usr/local/php5-static \
--disable-all \
--enable-shared=no \
--enable-static=yes \
--enable-inline-optimization \
--enable-hash \
--enable-mbstring \
--with-layout=GNU \
--enable-filter \
--with-pcre-regex \
--with-zlib \
--enable-json \
--enable-ctype \
--disable-redis-session \
--enable-redis
</code></p>

<h2>修改Makefile</h2>

<p>将
<code>
BUILD_CLI = $(LIBTOOL) --mode=link $(CC) -export-dynamic $(CFLAGS_CLEAN) $(EXTRA_CFLAGS) $(EXTRA_LDFLAGS_PROGRAM) $(LDFLAGS) $(PHP_RPATHS) $(PHP_GLOBAL_OBJS) $(PHP_BINARY_OBJS) $(PHP_CLI_OBJS) $(EXTRA_LIBS) $(ZEND_EXTRA_LIBS) -o $(SAPI_CLI_PATH)
BUILD_CGI = $(LIBTOOL) --mode=link $(CC) -export-dynamic $(CFLAGS_CLEAN) $(EXTRA_CFLAGS) $(EXTRA_LDFLAGS_PROGRAM) $(LDFLAGS) $(PHP_RPATHS) $(PHP_GLOBAL_OBJS) $(PHP_BINARY_OBJS) $(PHP_CGI_OBJS) $(EXTRA_LIBS) $(ZEND_EXTRA_LIBS) -o $(SAPI_CGI_PATH)
</code>
替换成
<code>
BUILD_CLI = $(LIBTOOL) --mode=link $(CC) $(CFLAGS_CLEAN) $(EXTRA_CFLAGS) $(EXTRA_LDFLAGS_PROGRAM) $(LDFLAGS) $(PHP_RPATHS) $(PHP_GLOBAL_OBJS) $(PHP_BINARY_OBJS) $(PHP_CLI_OBJS) $(EXTRA_LIBS) $(ZEND_EXTRA_LIBS) -all-static -o $(SAPI_CLI_PATH)
BUILD_CGI = $(LIBTOOL) --mode=link $(CC) $(CFLAGS_CLEAN) $(EXTRA_CFLAGS) $(EXTRA_LDFLAGS_PROGRAM) $(LDFLAGS) $(PHP_RPATHS) $(PHP_GLOBAL_OBJS) $(PHP_BINARY_OBJS) $(PHP_CGI_OBJS) $(EXTRA_LIBS) $(ZEND_EXTRA_LIBS) -all-static -o $(SAPI_CGI_PATH)
</code>
即：</p>

<p>在<code>BUILD_CLI</code>和<code>BUILD_CGI</code>对应的行中移除<code>-export-dynamic</code>，在<code>-o $(SAPI_CGI_PATH)</code>和<code>-o $(SAPI_CLI_PATH)</code>之前，添加<code>-all-static</code></p>

<h1>安装</h1>

<p><code>
make LDFLAGS=-ldl
sudo make install
</code></p>

<h1>检查</h1>

<p>在命令行执行</p>

<pre><code>$ file /usr/local/php5-static/bin/php
/usr/local/php5-static/bin/php: ELF 64-bit LSB executable, AMD x86-64, version 1 (SYSV), for GNU/Linux 2.6.9, statically linked, for GNU/Linux 2.6.9, not stripped

$ /usr/local/php5-static/bin/php -m
[PHP Modules]
Core
ctype
date
ereg
filter
hash
json
mbstring
pcre
redis
Reflection
SPL
standard
zlib

[Zend Modules]
</code></pre>

<p>因为可执行文件中包含了调试信息，所以体积较大</p>

<pre><code>$ ll -h /usr/local/php5-static/bin/php
-rwxr-xr-x 1 root root 18M 04-09 18:11 /usr/local/php5-static/bin/php
</code></pre>

<p>可以通过<code>strip</code>命令移除调试信息</p>

<pre><code>$ sudo strip /usr/local/php5-static/bin/php
$ ll -h /usr/local/php5-static/bin/php
-rwxr-xr-x 1 root root 6.1M 04-09 18:11 /usr/local/php5-static/bin/php
</code></pre>

<table>
<thead>
<tr>
<th align="center">原始文件大小</th>
<th align="center"> 去除符号表后大小</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>18M</code>      </td>
<td align="center"> <strong>6.1M</strong></td>
</tr>
</tbody>
</table>


<p><strong> reference :</strong></p>

<p>[^1] <a href="http://www.php.net/manual/zh/install.pecl.static.php">http://www.php.net/manual/zh/install.pecl.static.php</a></p>

<p>[^2] <a href="http://d.hatena.ne.jp/shimooka/comment/20110216/1297827454">http://d.hatena.ne.jp/shimooka/comment/20110216/1297827454</a></p>

<p>[^3] <a href="http://www.gnu.org/software/libtool/manual/html_node/Link-mode.html">http://www.gnu.org/software/libtool/manual/html_node/Link-mode.html</a></p>

<p>[^4] <a href="http://markmail.org/message/cpoenglavs4vwv32">http://markmail.org/message/cpoenglavs4vwv32</a></p>
]]></content>
  </entry>
  
</feed>
